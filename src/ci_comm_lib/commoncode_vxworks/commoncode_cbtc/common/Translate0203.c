/********************************************************
*                                                      
*  文件名   ：   Translate0203.c         
*  版权说明 ：   北京瑞安时代科技有限责任公司 
*  版本号   ：   1.0
*  创建时间 ：   2008.07.29
*  作者     ：   车载及协议部
*  功能描述 ：   0203转义处理函数                                                                    
*  修改记录 ：  
*
********************************************************/ 

#include "Translate0203.h"

/***********************************************************
* 函数名：  vobcTranslateTo0203
* 用  途：  将数据进行0203转义处理。
*           所能处理的长度为65535，因为受长度的类型UINT16限制。
* 参  数：  UINT8 *pSrc,    原始数据;
*           UINT8 *pTgt,    转义后的数据;
*           UINT16 SrcLen,  原始数据长度
* 返回值：  转义后的长度
***********************************************************/
UINT16 TranslateTo0203(const UINT8 *pSrc, UINT8 *pTgt,UINT16 SrcLen)
{
    UINT16 i = 0;/*循环变量*/
    UINT16 j = 0;/*转义后的长度*/

    /* 添加开头 */
    *(pTgt+j) = (UINT8)0x02;
    j++;

    /* 转义 */
    for(i=0;i<SrcLen;i++)
    {
        switch(*(pSrc+i))
        {
        case (UINT8)0x02:
            /*当前02字符*/
            *(pTgt+j) = (UINT8)0x10;
            j++;
            *(pTgt+j) = (UINT8)0x82;
            break;
        case (UINT8)0x03:
            /*当前03字符*/
            *(pTgt+j) = (UINT8)0x10;
            j++;
            *(pTgt+j) = (UINT8)0x83;
            break;
        case (UINT8)0x10:
            /*当前10字符*/
            *(pTgt+j) = (UINT8)0x10;
            j++;
            *(pTgt+j) = (UINT8)0x90;
            break;
        default:
            *(pTgt+j) = *(pSrc+i);
            break;
        }
        j++;
    }

    /* 添加结尾 */
    *(pTgt+j) = (UINT8)0x03;
    j++;

    return(j);
}


/***********************************************************
* 函数名：  vobcTranslateFrom0203
* 用  途：  将经过0203转义处理后的数据还原为原始数据
*           所能处理的长度为65535，因为受长度的类型UINT16限制。
* 参  数：  UINT8 *pSrc,    转义后的数据;
*           UINT8 *pTgt,    原始数据;
*           UINT16 SrcLen,  转义后的数据长度
* 返回值：  大于0：转义成功,返回原始数据长度
*           0：有不能转义的字符(比如0x10后跟随的字符不是0x82, 0x83, 0x90)，未能转义。
* 使用注意：在数据帧接受模块，将抛弃含有0x02,0x03的错误数据。
*           此处考虑到效率问题，未对数据中遇到0x02,0x03的情况进行处理。
***********************************************************/
UINT16 TranslateFrom0203(const UINT8 *pSrc, UINT8 *pTgt,UINT16 SrcLen)
{
    UINT16 j = 0;    /*指向pTgt数据的指针*/
    UINT16 k = 0;    /*指向pSrc数据的指针*/

    while(1)
    {
		if (k>=SrcLen)
		{
			break;
		}
        if((UINT8)0x10 == *(pSrc+k) ) 
        {
            /* 找出0x10，判断是否可以转义，并进行转义 */

            /*挪动数据指针到下一个数据*/
            k++; 

            if (k == SrcLen)
            {
                /*0x10是最后一个字符，返回错误*/
                return(0);
            }
			else
			{
				/*最后一个字符非0x10*/
			}

            if( ((UINT8)0x82!=*(pSrc+k)) && ((UINT8)0x83!=*(pSrc+k)) && ((UINT8)0x90!=*(pSrc+k)) )
            {
                /* 检查0x10后是否跟随非(0x82, 0x83, 0x90)的字符，若是则无法转义，返回转义错误。*/
                return(0);
            }
			else
			{
			}

            /*如果10后面是82，83，90则需要对这个字节进行转义*/
            *(pTgt+j) = *(pSrc+k) - (UINT8)0x80; 
        } 
        else
        {
            /*若无需转义，则直接拷贝数据*/
            *(pTgt+j) = *(pSrc+k);  
        }

        j++;
        k++;

    }

    /*返回转义后的数据长度或无法转义*/
    return j; 
} 
