/* $********** SCADE Suite KCG 32-bit 6.6 (build i19) ***********
** Command: kcg66.exe -config E:/Work-TCT/6@VBTC_OC/0@SoftwareSource/OCSimualtion20190524/src/app_oc/ScadeCode/config.txt
** Generation date: 2020-01-13T16:36:01
*************************************************************$ */

/* xscade source: E:/Work-TCT/6@VBTC_OC/0@SoftwareSource/OC_SCADE20190613/OC_SCADE.xscade */
const SLOCK_MAX : uint16 = 20;

type
  OC_Struct = {
    Id : uint16,
    SwitchNum : uint16,
    SwitchStateArray : SwitchState_Struct^SWITCH_MAX,
    SwitchFaultStateArray : uint8^SWITCH_MAX,
    SwitchInfoArray : SwitchInfo_Struct^SWITCH_MAX,
    SwitchLockTypeArray : uint8^SWITCH_MAX,
    SwitchELockArray : SwitchELock_Struct^SWITCH_MAX,
    SwitchSLockNumArray : uint16^SWITCH_MAX,
    SwitchSLockFlagArray : bool^SLOCK_MAX^SWITCH_MAX,
    SwitchSLockArray : SLock_Struct^SLOCK_MAX^SWITCH_MAX,
    TrainInfoFlagArray : uint16^TRAIN_MAX,
    TrainInfoArray : TrainInfo_Struct^TRAIN_MAX,
    TrainCommStateArray : bool^TRAIN_MAX,
    UCTLineNum : uint8,
    UCTLineInfoArray : UCT_Struct^TRAIN_MAX,
    PsdNum : uint16,
    PsdStateArray : PsdState_Struct^PSD_MAX,
    SignalNum : uint16,
    SignalStateArray : SignalState_Struct^SIGNAL_MAX,
    SignalInfoArray : SignalInfo_Struct^SIGNAL_MAX,
    EmpNum : uint16,
    EmpStateArray : Emp_Struct^EMP_MAX,
    StationInNum : uint16,
    StationInButtonArray : StationButton_Struct^EMP_MAX,
    StationOutNum : uint16,
    StationOutButtonArray : StationButton_Struct^EMP_MAX,
    AcNum : uint16,
    AcStateArray : Ac_Struct^AC_MAX,
    PhySecBlockIdFlagArray : uint8^PHYSEC_MAX,
    PhySecBlockIdArray : uint16^PHYSEC_MAX,
    MultSwitchNum : uint16,
    MultSwitchStateArray : MultSwitch_Struct^MULTSWITCH_MAX,
    ManRegionNum : uint16,
    ManRegionArray : ManRegion_Struct^MAX_MANREGION,
    AsbNum : uint16,
    AsbStateArray : StationButton_Struct^EMP_MAX,
    LsbNum : uint16,
    LsbStateArray : StationButton_Struct^EMP_MAX,
    DRBNum : uint16,
    DRBStateArray : DRB_Struct^AC_MAX,
    DANum : uint16,
    DAInfoArray : DAInfo_Struct^AC_MAX,
    HoldTrainNum : uint16,
    HoldTrainCmdDataFlagArray : bool^CMD_MAX,
    HoldTrainCmdDataArray : HoldTrain_CommandData_Struct^CMD_MAX,
    JumpTrainNum : uint16,
    JumpTrainCmdDataFlagArray : bool^CMD_MAX,
    JumpTrainCmdDataArray : JumpTrain_CommandData_Send_Struct^CMD_MAX,
    TSRNum : uint16,
    TSRDataArray : TSR_Struct^TSR_MAX,
    TSRValidFlag : uint16,
    RegionBlockFlag : uint16,
    RegionBlockPositionStruct : RegionBlockPosition_Struct,
    WSLoseInputFlag : uint8,
    TMCLoseInputFlag : uint8,
    TMCInputFlag : uint8,
    ElecPowerState : uint16,
    ElecPowerFlag : uint16,
    bRRBfITS : uint8,
    TMCEmapCheckVer : uint32,
    SysRunMode : uint8
  };

type SwitchState_Struct = { Id : uint16, Position : uint8, LockState : uint8 };

type
  SLock_Struct = {
    SLockId : uint16,
    SLockLevel : uint8,
    SLockSwitchState : uint8
  };

const SWITCH_MAX : uint16 = 200;

const PSD_MAX : uint16 = 200;

const EMP_MAX : uint16 = 200;

const AC_MAX : uint16 = 200;

const FG_MAX : uint16 = 200;

const CT_MAX : uint16 = 20;

const MULTSWITCH_MAX : uint16 = 2;

const LINK_MAX : uint16 = 200;

const SIGNAL_MAX : uint16 = 200;

type PsdState_Struct = { Id : uint16, State : uint8, DriveState : uint8 };

type
  ULock_Struct = {
    ULockId : uint16,
    ULockLevel : uint8,
    ULockSwitchState : uint8
  };

type Ac_Struct = { Id : uint16, State : uint8 };

type Emp_Struct = { Id : uint16, State : uint8 };

type
  MultSwitch_Struct = {
    Id : uint16,
    SwitchState : uint8,
    ULockValidFlag : bool^SLOCK_MAX,
    ULockNum : uint8,
    ULockArray : ULock_Struct^SLOCK_MAX
  };

type StationButton_Struct = { Id : uint16, State : uint8 };

type SignalState_Struct = { Id : uint16, State : uint8 };

type
  SwitchELock_Struct = {
    ELockId : uint16,
    ELockLevel : uint8,
    ELockSwitchState : uint8
  };

type SwitchFaultState_Array = uint8^SWITCH_MAX;

type
  SwitchInfo_Struct = {
    MoveState : uint8,
    SendCommondState : uint8,
    TimeHigh : uint32,
    TimeLow : uint32,
    CommandID : uint32,
    SendCycle : uint32,
    CommandSourceID : uint32
  };

type
  PowerLockCommandData_Struct = {
    SourceID : uint16,
    OC_ID : uint16,
    PowerLock : uint8,
    OnceOrTwice : uint8,
    CommandID : uint32,
    CommandParam : uint32
  };

const REGION_UNBLOCK : uint16 = 0xaa;

const REGION_BLOCK : uint16 = 0x55;

const
  NULL_SwitchLockState : SwitchLock_Array
    = [{ ELockId:0, ELockLevel:0, ELockSwitchState:0 }, {
          ELockId:0,
          ELockLevel:0,
          ELockSwitchState:0 }, { ELockId:0, ELockLevel:0, ELockSwitchState:0 },
      { ELockId:0, ELockLevel:0, ELockSwitchState:0 }, {
          ELockId:0,
          ELockLevel:0,
          ELockSwitchState:0 }, { ELockId:0, ELockLevel:0, ELockSwitchState:0 },
      { ELockId:0, ELockLevel:0, ELockSwitchState:0 }, {
          ELockId:0,
          ELockLevel:0,
          ELockSwitchState:0 }, { ELockId:0, ELockLevel:0, ELockSwitchState:0 },
      { ELockId:0, ELockLevel:0, ELockSwitchState:0 }, {
          ELockId:0,
          ELockLevel:0,
          ELockSwitchState:0 }, { ELockId:0, ELockLevel:0, ELockSwitchState:0 },
      { ELockId:0, ELockLevel:0, ELockSwitchState:0 }, {
          ELockId:0,
          ELockLevel:0,
          ELockSwitchState:0 }, { ELockId:0, ELockLevel:0, ELockSwitchState:0 },
      { ELockId:0, ELockLevel:0, ELockSwitchState:0 }, {
          ELockId:0,
          ELockLevel:0,
          ELockSwitchState:0 }, { ELockId:0, ELockLevel:0, ELockSwitchState:0 },
      { ELockId:0, ELockLevel:0, ELockSwitchState:0 }, {
          ELockId:0,
          ELockLevel:0,
          ELockSwitchState:0 }, { ELockId:0, ELockLevel:0, ELockSwitchState:0 },
      { ELockId:0, ELockLevel:0, ELockSwitchState:0 }, {
          ELockId:0,
          ELockLevel:0,
          ELockSwitchState:0 }, { ELockId:0, ELockLevel:0, ELockSwitchState:0 },
      { ELockId:0, ELockLevel:0, ELockSwitchState:0 }, {
          ELockId:0,
          ELockLevel:0,
          ELockSwitchState:0 }, { ELockId:0, ELockLevel:0, ELockSwitchState:0 },
      { ELockId:0, ELockLevel:0, ELockSwitchState:0 }, {
          ELockId:0,
          ELockLevel:0,
          ELockSwitchState:0 }, { ELockId:0, ELockLevel:0, ELockSwitchState:0 },
      { ELockId:0, ELockLevel:0, ELockSwitchState:0 }, {
          ELockId:0,
          ELockLevel:0,
          ELockSwitchState:0 }, { ELockId:0, ELockLevel:0, ELockSwitchState:0 },
      { ELockId:0, ELockLevel:0, ELockSwitchState:0 }, {
          ELockId:0,
          ELockLevel:0,
          ELockSwitchState:0 }, { ELockId:0, ELockLevel:0, ELockSwitchState:0 },
      { ELockId:0, ELockLevel:0, ELockSwitchState:0 }, {
          ELockId:0,
          ELockLevel:0,
          ELockSwitchState:0 }, { ELockId:0, ELockLevel:0, ELockSwitchState:0 },
      { ELockId:0, ELockLevel:0, ELockSwitchState:0 }, {
          ELockId:0,
          ELockLevel:0,
          ELockSwitchState:0 }, { ELockId:0, ELockLevel:0, ELockSwitchState:0 },
      { ELockId:0, ELockLevel:0, ELockSwitchState:0 }, {
          ELockId:0,
          ELockLevel:0,
          ELockSwitchState:0 }, { ELockId:0, ELockLevel:0, ELockSwitchState:0 },
      { ELockId:0, ELockLevel:0, ELockSwitchState:0 }, {
          ELockId:0,
          ELockLevel:0,
          ELockSwitchState:0 }, { ELockId:0, ELockLevel:0, ELockSwitchState:0 },
      { ELockId:0, ELockLevel:0, ELockSwitchState:0 }, {
          ELockId:0,
          ELockLevel:0,
          ELockSwitchState:0 }, { ELockId:0, ELockLevel:0, ELockSwitchState:0 },
      { ELockId:0, ELockLevel:0, ELockSwitchState:0 }, {
          ELockId:0,
          ELockLevel:0,
          ELockSwitchState:0 }, { ELockId:0, ELockLevel:0, ELockSwitchState:0 },
      { ELockId:0, ELockLevel:0, ELockSwitchState:0 }, {
          ELockId:0,
          ELockLevel:0,
          ELockSwitchState:0 }, { ELockId:0, ELockLevel:0, ELockSwitchState:0 },
      { ELockId:0, ELockLevel:0, ELockSwitchState:0 }, {
          ELockId:0,
          ELockLevel:0,
          ELockSwitchState:0 }, { ELockId:0, ELockLevel:0, ELockSwitchState:0 },
      { ELockId:0, ELockLevel:0, ELockSwitchState:0 }, {
          ELockId:0,
          ELockLevel:0,
          ELockSwitchState:0 }, { ELockId:0, ELockLevel:0, ELockSwitchState:0 },
      { ELockId:0, ELockLevel:0, ELockSwitchState:0 }, {
          ELockId:0,
          ELockLevel:0,
          ELockSwitchState:0 }, { ELockId:0, ELockLevel:0, ELockSwitchState:0 },
      { ELockId:0, ELockLevel:0, ELockSwitchState:0 }, {
          ELockId:0,
          ELockLevel:0,
          ELockSwitchState:0 }, { ELockId:0, ELockLevel:0, ELockSwitchState:0 },
      { ELockId:0, ELockLevel:0, ELockSwitchState:0 }, {
          ELockId:0,
          ELockLevel:0,
          ELockSwitchState:0 }, { ELockId:0, ELockLevel:0, ELockSwitchState:0 },
      { ELockId:0, ELockLevel:0, ELockSwitchState:0 }, {
          ELockId:0,
          ELockLevel:0,
          ELockSwitchState:0 }, { ELockId:0, ELockLevel:0, ELockSwitchState:0 },
      { ELockId:0, ELockLevel:0, ELockSwitchState:0 }, {
          ELockId:0,
          ELockLevel:0,
          ELockSwitchState:0 }, { ELockId:0, ELockLevel:0, ELockSwitchState:0 },
      { ELockId:0, ELockLevel:0, ELockSwitchState:0 }, {
          ELockId:0,
          ELockLevel:0,
          ELockSwitchState:0 }, { ELockId:0, ELockLevel:0, ELockSwitchState:0 },
      { ELockId:0, ELockLevel:0, ELockSwitchState:0 }, {
          ELockId:0,
          ELockLevel:0,
          ELockSwitchState:0 }, { ELockId:0, ELockLevel:0, ELockSwitchState:0 },
      { ELockId:0, ELockLevel:0, ELockSwitchState:0 }, {
          ELockId:0,
          ELockLevel:0,
          ELockSwitchState:0 }, { ELockId:0, ELockLevel:0, ELockSwitchState:0 },
      { ELockId:0, ELockLevel:0, ELockSwitchState:0 }, {
          ELockId:0,
          ELockLevel:0,
          ELockSwitchState:0 }, { ELockId:0, ELockLevel:0, ELockSwitchState:0 },
      { ELockId:0, ELockLevel:0, ELockSwitchState:0 }, {
          ELockId:0,
          ELockLevel:0,
          ELockSwitchState:0 }, { ELockId:0, ELockLevel:0, ELockSwitchState:0 },
      { ELockId:0, ELockLevel:0, ELockSwitchState:0 }, {
          ELockId:0,
          ELockLevel:0,
          ELockSwitchState:0 }, { ELockId:0, ELockLevel:0, ELockSwitchState:0 },
      { ELockId:0, ELockLevel:0, ELockSwitchState:0 }, {
          ELockId:0,
          ELockLevel:0,
          ELockSwitchState:0 }, { ELockId:0, ELockLevel:0, ELockSwitchState:0 },
      { ELockId:0, ELockLevel:0, ELockSwitchState:0 }, {
          ELockId:0,
          ELockLevel:0,
          ELockSwitchState:0 }, { ELockId:0, ELockLevel:0, ELockSwitchState:0 },
      { ELockId:0, ELockLevel:0, ELockSwitchState:0 }, {
          ELockId:0,
          ELockLevel:0,
          ELockSwitchState:0 }, { ELockId:0, ELockLevel:0, ELockSwitchState:0 },
      { ELockId:0, ELockLevel:0, ELockSwitchState:0 }, {
          ELockId:0,
          ELockLevel:0,
          ELockSwitchState:0 }, { ELockId:0, ELockLevel:0, ELockSwitchState:0 },
      { ELockId:0, ELockLevel:0, ELockSwitchState:0 }, {
          ELockId:0,
          ELockLevel:0,
          ELockSwitchState:0 }, { ELockId:0, ELockLevel:0, ELockSwitchState:0 },
      { ELockId:0, ELockLevel:0, ELockSwitchState:0 }, {
          ELockId:0,
          ELockLevel:0,
          ELockSwitchState:0 }, { ELockId:0, ELockLevel:0, ELockSwitchState:0 },
      { ELockId:0, ELockLevel:0, ELockSwitchState:0 }, {
          ELockId:0,
          ELockLevel:0,
          ELockSwitchState:0 }, { ELockId:0, ELockLevel:0, ELockSwitchState:0 },
      { ELockId:0, ELockLevel:0, ELockSwitchState:0 }, {
          ELockId:0,
          ELockLevel:0,
          ELockSwitchState:0 }, { ELockId:0, ELockLevel:0, ELockSwitchState:0 },
      { ELockId:0, ELockLevel:0, ELockSwitchState:0 }, {
          ELockId:0,
          ELockLevel:0,
          ELockSwitchState:0 }, { ELockId:0, ELockLevel:0, ELockSwitchState:0 },
      { ELockId:0, ELockLevel:0, ELockSwitchState:0 }, {
          ELockId:0,
          ELockLevel:0,
          ELockSwitchState:0 }, { ELockId:0, ELockLevel:0, ELockSwitchState:0 },
      { ELockId:0, ELockLevel:0, ELockSwitchState:0 }, {
          ELockId:0,
          ELockLevel:0,
          ELockSwitchState:0 }, { ELockId:0, ELockLevel:0, ELockSwitchState:0 },
      { ELockId:0, ELockLevel:0, ELockSwitchState:0 }, {
          ELockId:0,
          ELockLevel:0,
          ELockSwitchState:0 }, { ELockId:0, ELockLevel:0, ELockSwitchState:0 },
      { ELockId:0, ELockLevel:0, ELockSwitchState:0 }, {
          ELockId:0,
          ELockLevel:0,
          ELockSwitchState:0 }, { ELockId:0, ELockLevel:0, ELockSwitchState:0 },
      { ELockId:0, ELockLevel:0, ELockSwitchState:0 }, {
          ELockId:0,
          ELockLevel:0,
          ELockSwitchState:0 }, { ELockId:0, ELockLevel:0, ELockSwitchState:0 },
      { ELockId:0, ELockLevel:0, ELockSwitchState:0 }, {
          ELockId:0,
          ELockLevel:0,
          ELockSwitchState:0 }, { ELockId:0, ELockLevel:0, ELockSwitchState:0 },
      { ELockId:0, ELockLevel:0, ELockSwitchState:0 }, {
          ELockId:0,
          ELockLevel:0,
          ELockSwitchState:0 }, { ELockId:0, ELockLevel:0, ELockSwitchState:0 },
      { ELockId:0, ELockLevel:0, ELockSwitchState:0 }, {
          ELockId:0,
          ELockLevel:0,
          ELockSwitchState:0 }, { ELockId:0, ELockLevel:0, ELockSwitchState:0 },
      { ELockId:0, ELockLevel:0, ELockSwitchState:0 }, {
          ELockId:0,
          ELockLevel:0,
          ELockSwitchState:0 }, { ELockId:0, ELockLevel:0, ELockSwitchState:0 },
      { ELockId:0, ELockLevel:0, ELockSwitchState:0 }, {
          ELockId:0,
          ELockLevel:0,
          ELockSwitchState:0 }, { ELockId:0, ELockLevel:0, ELockSwitchState:0 },
      { ELockId:0, ELockLevel:0, ELockSwitchState:0 }, {
          ELockId:0,
          ELockLevel:0,
          ELockSwitchState:0 }, { ELockId:0, ELockLevel:0, ELockSwitchState:0 },
      { ELockId:0, ELockLevel:0, ELockSwitchState:0 }, {
          ELockId:0,
          ELockLevel:0,
          ELockSwitchState:0 }, { ELockId:0, ELockLevel:0, ELockSwitchState:0 },
      { ELockId:0, ELockLevel:0, ELockSwitchState:0 }, {
          ELockId:0,
          ELockLevel:0,
          ELockSwitchState:0 }, { ELockId:0, ELockLevel:0, ELockSwitchState:0 },
      { ELockId:0, ELockLevel:0, ELockSwitchState:0 }, {
          ELockId:0,
          ELockLevel:0,
          ELockSwitchState:0 }, { ELockId:0, ELockLevel:0, ELockSwitchState:0 },
      { ELockId:0, ELockLevel:0, ELockSwitchState:0 }, {
          ELockId:0,
          ELockLevel:0,
          ELockSwitchState:0 }, { ELockId:0, ELockLevel:0, ELockSwitchState:0 },
      { ELockId:0, ELockLevel:0, ELockSwitchState:0 }, {
          ELockId:0,
          ELockLevel:0,
          ELockSwitchState:0 }, { ELockId:0, ELockLevel:0, ELockSwitchState:0 },
      { ELockId:0, ELockLevel:0, ELockSwitchState:0 }, {
          ELockId:0,
          ELockLevel:0,
          ELockSwitchState:0 }, { ELockId:0, ELockLevel:0, ELockSwitchState:0 },
      { ELockId:0, ELockLevel:0, ELockSwitchState:0 }, {
          ELockId:0,
          ELockLevel:0,
          ELockSwitchState:0 }, { ELockId:0, ELockLevel:0, ELockSwitchState:0 },
      { ELockId:0, ELockLevel:0, ELockSwitchState:0 }, {
          ELockId:0,
          ELockLevel:0,
          ELockSwitchState:0 }, { ELockId:0, ELockLevel:0, ELockSwitchState:0 },
      { ELockId:0, ELockLevel:0, ELockSwitchState:0 }, {
          ELockId:0,
          ELockLevel:0,
          ELockSwitchState:0 }, { ELockId:0, ELockLevel:0, ELockSwitchState:0 },
      { ELockId:0, ELockLevel:0, ELockSwitchState:0 }, {
          ELockId:0,
          ELockLevel:0,
          ELockSwitchState:0 }, { ELockId:0, ELockLevel:0, ELockSwitchState:0 },
      { ELockId:0, ELockLevel:0, ELockSwitchState:0 }, {
          ELockId:0,
          ELockLevel:0,
          ELockSwitchState:0 }, { ELockId:0, ELockLevel:0, ELockSwitchState:0 },
      { ELockId:0, ELockLevel:0, ELockSwitchState:0 }, {
          ELockId:0,
          ELockLevel:0,
          ELockSwitchState:0 }, { ELockId:0, ELockLevel:0, ELockSwitchState:0 },
      { ELockId:0, ELockLevel:0, ELockSwitchState:0 }, {
          ELockId:0,
          ELockLevel:0,
          ELockSwitchState:0 }, { ELockId:0, ELockLevel:0, ELockSwitchState:0 },
      { ELockId:0, ELockLevel:0, ELockSwitchState:0 }, {
          ELockId:0,
          ELockLevel:0,
          ELockSwitchState:0 }, { ELockId:0, ELockLevel:0, ELockSwitchState:0 },
      { ELockId:0, ELockLevel:0, ELockSwitchState:0 }, {
          ELockId:0,
          ELockLevel:0,
          ELockSwitchState:0 }];

const FLAG_UNSET : uint8 = 0xaa;

const FLAG_SET : uint8 = 0x55;

const ELEC_TWICE_OUT : uint16 = 0x02;

const ELEC_TWICE : uint8 = 0xaa;

const ELEC_ONECE_OUT : uint16 = 0x01;

const ELEC_ONECE : uint8 = 0x55;

const ELEC_NONE_OUT : uint16 = 0x00;

const CMD_MAX : uint8 = 100;

type SwitchLock_Array = SwitchELock_Struct^SWITCH_MAX;

const SWITCH_FAULT : uint8 = 0x55;

const SWITCH_NORMAL : uint8 = 0xaa;

type
  SignalInfo_Struct = {
    SourceId : uint16,
    PreSourceId : uint16,
    SignalExpState : uint16,
    SignalCtrlTime : uint16
  };

type
  Signal_SendCommandData_Struct = {
    SourceID : uint16,
    SignalID : uint16,
    SignalType : uint16,
    CommandID : uint32,
    TimeHigh : uint32,
    TimeLow : uint32
  };

const SIGNAL_CTR_MAX_TIME : uint16 = 0x05;

type
  VOBCLock_CommandData_Struct = {
    SourceID : uint16,
    SwitchID : uint16,
    LockAdd_Delete : uint8,
    ELcok_SLock : uint8,
    LockPositionNormal_Reverse : uint8,
    CommandID : uint32,
    TimeHigh : uint32,
    TimeLow : uint32
  };

type
  TSR_CTRL_CommandData_Struct = {
    SourceID : uint16,
    TSRSpeed : uint8,
    TSRFlag : uint16,
    TSRSectionNum : uint8,
    TSRSectionIdBuf : uint16^TSR_SECTION_MAX,
    CommandID : uint32,
    TimeHigh : uint32,
    TimeLow : uint32
  };

type
  Switch_Reset_CommandData_Struct = {
    SourceID : uint16,
    SwitchID : uint16,
    ResetLable : uint16,
    CommandID : uint32,
    TimeHigh : uint32,
    TimeLow : uint32
  };

type
  Switch_CommandData_Struct = {
    SourceID : uint16,
    SwitchID : uint16,
    LockPositionNormal_Reverse : uint8,
    CommandID : uint32,
    TimeHigh : uint32,
    TimeLow : uint32
  };

type
  Region_Block_CommandData_Struct = {
    SourceID : uint16,
    Region : uint16,
    BlockLable : uint16,
    CommandID : uint32,
    TimeHigh : uint32,
    TimeLow : uint32
  };

type
  PSD_CommandData_Struct = {
    SourceID : uint16,
    PSDID : uint16,
    Open_Close : uint8,
    CommandID : uint32,
    TimeHigh : uint32,
    TimeLow : uint32
  };

type
  MultSwitch_CommandData_Struct = {
    SourceID : uint16,
    MultSwitchID : uint16,
    LockAdd_Delete : uint8,
    Position1_2 : uint8,
    All_Self : uint8,
    CommandID : uint32,
    TimeHigh : uint32,
    TimeLow : uint32
  };

type
  JumpTrain_CommandData_Struct = {
    SourceID : uint16,
    StationID : uint16,
    JumpTrainStatus : uint16,
    JumpTrainOrStation : uint16,
    JumpTrainID : uint16,
    CommandID : uint32,
    TimeHigh : uint32,
    TimeLow : uint32
  };

type
  HoldTrain_CommandData_Struct = {
    SourceID : uint16,
    StationID : uint16,
    HoldTrainStatus : uint16,
    CommandID : uint32,
    TimeHigh : uint32,
    TimeLow : uint32
  };

type
  DeleteAddTrain_CommandData_Struct = {
    SourceID : uint16,
    DelOrAdd : uint8,
    IVOCID : uint16,
    DeleteTrainOneorAll : uint16,
    CommandID : uint32,
    TimeHigh : uint32,
    TimeLow : uint32
  };

type
  CTMan_CommandData_Struct = {
    OCRegionID : uint16,
    SourceID : uint16,
    TrainContact : uint8,
    IP : uint32
  };

type
  CommandData_Struct = {
    CommandNum_Switch : uint16,
    OCRevSwitchCmdDataArray : Switch_CommandData_Struct^CMD_MAX,
    OCRevSwitchCmdDataFlagArray : bool^CMD_MAX,
    CommandNum_MultSwitch : uint16,
    OCRevMultSwitchCmdDataArray : MultSwitch_CommandData_Struct^CMD_MAX,
    CommandNum_ATSLock : uint16,
    OCRevATSLockCmdDataArray : ATSLock_CommandData_Struct^CMD_MAX,
    OCRevATSLockCmdDataFlagArray : bool^CMD_MAX,
    CommandNum_VOBCLock : uint16,
    OCRevVOBCLockCmdDataArray : VOBCLock_CommandData_Struct^CMD_MAX,
    OCRevVOBCLockCmdDataFlagArray : bool^CMD_MAX,
    CommandNum_HCOCLock : uint16,
    OCRevHCOCLockCmdDataArray : ATSLock_CommandData_Struct^CMD_MAX,
    OCRevHCOCLockCmdDataFlagArray : bool^CMD_MAX,
    CommandNum_TMCLock : uint16,
    OCRevTMCLockCmdDataArray : VOBCLock_CommandData_Struct^CMD_MAX,
    OCRevTMCLockCmdDataFlagArray : bool^CMD_MAX,
    CommandNum_PSD : uint16,
    OCRevPSDCmdDataArray : PSD_CommandData_Struct^CMD_MAX,
    CommandNum_AC : uint16,
    OCRevACCmdDataArray : AC_CommandData_Struct^CMD_MAX,
    CommandNum_CTMan : uint16,
    OCRevCTManCmdDataArray : CTMan_CommandData_Struct^CMD_MAX,
    CommandNum_ATSLockDelete : uint16,
    OCRevATSLockDeleteCmdDataArray : ATSLockDelete_CommandData_Struct^CMD_MAX,
    CommandNum_HoldTrain : uint16,
    OCRevHoldTrainCmdDataArray : HoldTrain_CommandData_Struct^CMD_MAX,
    CommandNum_JumpTrain : uint16,
    OCRevJumpTrainCmdDataArray : JumpTrain_CommandData_Struct^CMD_MAX,
    CommandNum_DeleteAddTrain : uint16,
    OCRevDeleteAddTrainCmdDataArray : DeleteAddTrain_CommandData_Struct^CMD_MAX,
    OCRevPowerLockCmdDataArray : PowerLockCommandData_Struct,
    CommandNum_SwitchReset : uint16,
    OCRevATSSwitchResetCmdDataArray : Switch_Reset_CommandData_Struct^CMD_MAX,
    CommandNum_RegionBlock : uint16,
    OCRevRegionBlockCmdDataArray : Region_Block_CommandData_Struct^CMD_MAX,
    CommandNum_PhySecBlock : uint16,
    OCRevPhySecBlockCmdDataArray : PhySec_Block_CommandData_Struct^CMD_MAX,
    CommandNum_SignalCtrl : uint16,
    OCRevSignalCtrlCmdDataArray : Signal_SendCommandData_Struct^CMD_MAX,
    CommandNum_TSRCtrl : uint16,
    OCRevTSRCtrlCmdDataArray : TSR_CTRL_CommandData_Struct^CMD_MAX,
    CommandNum_DRB : uint16,
    OCRevDRBCmdDataArray : DRB_CommandData_Struct^CMD_MAX
  };

type
  ATSLockDelete_CommandData_Struct = {
    SourceID : uint16,
    SwitchID : uint16,
    ZeroLable : uint16,
    CommandID : uint32,
    TimeHigh : uint32,
    TimeLow : uint32
  };

type
  ATSLock_CommandData_Struct = {
    SourceID : uint16,
    SwitchID : uint16,
    LockAdd_Delete : uint8,
    ELcok_SLock : uint8,
    LockPositionNormal_Reverse : uint8,
    DestID : uint16,
    CommandID : uint32,
    TimeHigh : uint32,
    TimeLow : uint32
  };

type
  AC_CommandData_Struct = {
    SourceID : uint16,
    ACID : uint16,
    ResetAct : uint8
  };

const
  NULL_SignalCtrlCmdData : Signal_SendCommandData_Struct
    = {
        SourceID:0,
        SignalID:0,
        SignalType:0,
        CommandID:0,
        TimeHigh:0,
        TimeLow:0 };

const TMC_ID : uint16 = 0x2B01;

const ITS_ID : uint16 = 0x0301;

const HCOC_ID : uint16 = 0x1501;

const WS_ID : uint16 = 0x4D01;

const LOSE_TMC_INPUT_MAX_CYCLE : uint8 = 0x05;

const SIGNAL_RED : uint16 = 0x01;

const SIGNAL_GREEN : uint16 = 0x04;

const SIGNAL_YELLOW : uint16 = 0x02;

const SIGNAL_OFF : uint16 = 0x06;

type
  UCT_Struct = {
    ID : uint16,
    DevPos : uint8,
    UCTLineDir : uint8,
    UCTLineHeadLink : uint16,
    UCTLineHeadOffset : uint32,
    UCTLineTailLink : uint16,
    UCTLineTailOffset : uint32,
    UCTLineLinkListNum : uint8,
    UCTLineLinkID : uint16^LINK_LIST_NUM_MAX
  };

const
  NULL_SignalInfo : SignalInfo_Struct
    = { SourceId:0, PreSourceId:0, SignalExpState:0, SignalCtrlTime:0 };

type
  Switch_SendCommandData_Struct = {
    SourceID : uint16,
    SwitchID : uint16,
    LockPositionNormal_Reverse : uint8
  };

const LOCK_Q_SWITCH_STATUS_MAIN : uint8 = 0x55;

const LOCK_Q_SWITCH_STATUS_SIDE : uint8 = 0xAA;

const LOCK_MAIN : uint8 = 0x55;

const LOCK_SIDE : uint8 = 0xaa;

const SWITCH_BUFFER_NUM : uint8 = 0x05;

const
  NULL_Switch_CommandData : Switch_CommandData_Struct
    = {
        SourceID:0,
        SwitchID:0,
        LockPositionNormal_Reverse:0,
        CommandID:0,
        TimeHigh:0,
        TimeLow:0 };

const SWITCH_CHANGE_TIME : uint32 = 75;

const
  NULL_SwitchInfo : SwitchInfo_Struct
    = {
        MoveState:0,
        SendCommondState:0,
        TimeHigh:0,
        TimeLow:0,
        CommandID:0,
        SendCycle:0,
        CommandSourceID:0 };

const
  NULL_SwitchELock : SwitchELock_Struct
    = { ELockId:0, ELockLevel:0, ELockSwitchState:0 };

const NULL_SwitchState : SwitchState_Struct = { Id:0, Position:0, LockState:0 };

const LOSE_WS_INPUT_MAX_CYCLE : uint8 = 0x03;

type
  ATSLockDelete_CountDown_Struct = {
    SwitchID_ATSQingLing : uint16,
    Time_ATSQingLing : uint32
  };

const
  NULL_SLock : SLock_Struct = { SLockId:0, SLockLevel:0, SLockSwitchState:0 };

const LOCK_E : uint8 = 0xAA;

const LOCK_S : uint8 = 0x55;

const DEL_LOCK : uint8 = 0xAA;

const ADD_LOCK : uint8 = 0x55;

const SWITCH_POSITION_MAIN : uint8 = 0x01;

const SWITCH_POSITION_SIDE : uint8 = 0x02;

type
  TrainInfo_Struct = {
    ID_CT : uint16,
    Contact_CT : uint8,
    CycNum_LoseContact : uint8,
    IP_CT : uint8^4,
    IP : uint32,
    Cycle : uint32,
    LCTConfirm : uint8,
    DevPos : uint8,
    TrainMode : uint8,
    TrainLevel : uint8,
    PassFlag : uint8,
    DetecAreaID : uint16,
    TrainDir : uint8,
    TrainHeadLink : uint16,
    TrainHeadOffset : uint32,
    TrainTailLink : uint16,
    TrainTailOffset : uint32,
    TrainLocApply : uint8,
    TrainMaxSafeHeadLink : uint16,
    TrainMaxSafeHeadOffset : uint32,
    TrainMinSafeTailLink : uint16,
    TrainMinSafeTailOffset : uint32,
    IVOC_Direction : uint8,
    IVOC_SN : uint32,
    IVOC_SPEED : uint16,
    IVOC_SPEED_DIR : uint8,
    IVOC_MA_START_LINK : uint16,
    IVOC_MA_START_OFFSET : uint32,
    IVOC_MA_END_LINK : uint16,
    IVOC_MA_END_OFFSET : uint32,
    IVOC_MA_DIR : uint8
  };

const TRAIN_MAX : uint8 = 200;

const LOSE_CONTACT_MAX_CYCLE : uint32 = 10;

const LINK_APPLY : uint8 = 0x01;

const LINK_MAINTAIN : uint8 = 0x03;

const LINKBREAK_APPLY : uint8 = 0x02;

const DEL_UCT : uint8 = 0xAA;

const ADD_UCT : uint8 = 0x55;

const DELETE_TRAIN_ALL : uint16 = 0xAA;

const DELETE_TRAIN_ONE : uint16 = 0x55;

sensor g_dwOCCycle : uint32;

sensor g_stOCRevCmdDataStru : CommandData_Struct;

sensor g_stOC : OC_Struct;

const ATS_LOCK_ONLY_TIME : uint32 = 0x64;

const DELETE_ALL_MULT_SWTICH : uint8 = 0x55;

const DELETE_SELF_MULT_SWTICH : uint8 = 0xaa;

const
  NULL_MultSwitch_Struct : MultSwitch_Struct
    = {
        Id:0,
        SwitchState:0,
        ULockValidFlag:[false, false, false, false, false, false, false, false,
          false, false, false, false, false, false, false, false, false, false,
          false, false],
        ULockNum:0,
        ULockArray:[{ ULockId:0, ULockLevel:0, ULockSwitchState:0 }, {
              ULockId:0,
              ULockLevel:0,
              ULockSwitchState:0 }, {
              ULockId:0,
              ULockLevel:0,
              ULockSwitchState:0 }, {
              ULockId:0,
              ULockLevel:0,
              ULockSwitchState:0 }, {
              ULockId:0,
              ULockLevel:0,
              ULockSwitchState:0 }, {
              ULockId:0,
              ULockLevel:0,
              ULockSwitchState:0 }, {
              ULockId:0,
              ULockLevel:0,
              ULockSwitchState:0 }, {
              ULockId:0,
              ULockLevel:0,
              ULockSwitchState:0 }, {
              ULockId:0,
              ULockLevel:0,
              ULockSwitchState:0 }, {
              ULockId:0,
              ULockLevel:0,
              ULockSwitchState:0 }, {
              ULockId:0,
              ULockLevel:0,
              ULockSwitchState:0 }, {
              ULockId:0,
              ULockLevel:0,
              ULockSwitchState:0 }, {
              ULockId:0,
              ULockLevel:0,
              ULockSwitchState:0 }, {
              ULockId:0,
              ULockLevel:0,
              ULockSwitchState:0 }, {
              ULockId:0,
              ULockLevel:0,
              ULockSwitchState:0 }, {
              ULockId:0,
              ULockLevel:0,
              ULockSwitchState:0 }, {
              ULockId:0,
              ULockLevel:0,
              ULockSwitchState:0 }, {
              ULockId:0,
              ULockLevel:0,
              ULockSwitchState:0 }, {
              ULockId:0,
              ULockLevel:0,
              ULockSwitchState:0 }, {
              ULockId:0,
              ULockLevel:0,
              ULockSwitchState:0 }] };

const LCT_INVALID : uint8 = 0x02;

const LCT : uint8 = 0x01;

const TRAIN_VBTC : uint8 = 0x02;

const TRAIN_RM : uint8 = 0x01;

const NOT_IN_MANAGE_AREA : uint8 = 0xAA;

const IN_MANAGE_AREA : uint8 = 0x55;

type DRB_Struct = { Id : uint16, State : uint8 };

type DAInfo_Struct = { Id : uint16, State : uint8, TrainDir : uint8 };

const DA_MAX : uint16 = 10;

type
  JumpTrain_CommandData_Send_Struct = {
    StationID : uint16,
    JumpTrainNum : uint16,
    JumpTrainIDArray : uint16^CT_MAX
  };

type
  TSR_Struct = {
    TSRSpeed : uint8,
    Flag : uint8,
    TSRSectionNum : uint8,
    TSRSectionIdBuf : uint16^TSR_SECTION_MAX
  };

const ADD_HOLD_TRAIN : uint16 = 0x55;

const DEL_HOLD_TRAIN : uint16 = 0xAA;

const ADD_JUMP_TRAIN : uint16 = 0x55;

const DEL_JUMP_TRAIN : uint16 = 0xAA;

const JUMP_ALL_TRAIN : uint16 = 0x55;

const JUMP_SPECIFIC_TRAIN : uint16 = 0xAA;

const
  NULL_JumpTrain_CommandData_Send_Struct : JumpTrain_CommandData_Send_Struct
    = {
        StationID:0,
        JumpTrainNum:0,
        JumpTrainIDArray:[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
          0, 0] };

const
  NULL_TsrData : TSR_Struct
    = {
        TSRSpeed:0,
        Flag:0,
        TSRSectionNum:0,
        TSRSectionIdBuf:[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
          0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
          0, 0, 0, 0, 0, 0, 0, 0, 0] };

const TSR_SET : uint16 = 0x55;

const TSR_CANCEL : uint16 = 0xAA;

type
  DRB_CommandData_Struct = {
    SourceId : uint16,
    DRBid : uint16,
    DRBStatus : uint16
  };

type ManRegion_Struct = { RegionID : uint16, RegionBlockFlag : uint8 };

const MAX_MANREGION : uint16 = 10;

sensor g_OCNO : uint16;

sensor g_OCID : uint16;

const TSR_MAX : uint8 = 100;

const TSR_SECTION_MAX : uint8 = 50;

type
  RegionBlockPosition_Struct = {
    AllLine : uint16,
    UpDir : uint16,
    DownDir : uint16
  };

const REGION_BLOCK_SET : uint16 = 0x55;

const REGION_BLOCK_RELIEVE : uint16 = 0xaa;

type
  Its_SendCommandData_Struct = {
    SourceID : uint16,
    CommandType : uint16,
    CommandID : uint32,
    CommandParam : uint32
  };

const ELEC_LOCK : uint16 = 0xaa;

const ELEC_UNLOCK : uint16 = 0x55;

type
  SendCommandData_Struct = {
    CommandType : uint8,
    CommandId : uint32,
    CommandParam : uint32
  };

const PHYSEC_MAX : uint16 = 50;

type
  PhySec_Block_CommandData_Struct = {
    PhySecId : uint16,
    BlockLable : uint16,
    CommandID : uint32
  };

const PHYSEC_BLOCK_SET : uint16 = 0x55;

const PHYSEC_BLOCK_RELIEVE : uint16 = 0xaa;

const LINK_LIST_NUM_MAX : uint8 = 0xff;

const MODE_VBTC : uint8 = 0x55;

const MODE_SHADOW : uint8 = 0xaa;


/* xscade source: E:/Work-TCT/6@VBTC_OC/0@SoftwareSource/OC_SCADE20190613/LockQSwitchStatus2SwitchStatus.xscade */
function #pragma kcg expand #end
  #pragma kcg separate_io #end LockQSwitchStatus2SwitchStatus(
    LockQSwitchStatus : uint8)
  returns (SwitchStatus : uint8)
var
  _L1 : uint8;
  _L2 : uint8;
  _L3 : bool;
  _L4 : uint8;
  _L5 : uint8;
  _L6 : uint8;
  _L8 : uint8;
  _L7 : bool;
  _L10 : uint8;
  _L11 : uint8;
  _L12 : uint8;
let
  _L1= #1 if _L3 then (_L5) else (_L6);
  _L2= LockQSwitchStatus;
  _L3= _L2 #1 = _L4;
  _L4= LOCK_MAIN;
  _L5= SWITCH_POSITION_MAIN;
  _L6= #2 if _L7 then (_L11) else (_L12);
  _L7= _L8 #2 = _L10;
  _L8= LockQSwitchStatus;
  _L10= LOCK_SIDE;
  _L11= SWITCH_POSITION_SIDE;
  _L12= 0_ui8;
  SwitchStatus= _L1;
tel


/* xscade source: E:/Work-TCT/6@VBTC_OC/0@SoftwareSource/OC_SCADE20190613/PowerLockDeleteManage.xscade */
package PowerLockDeleteManage
  function #pragma kcg doc "Graphical_1" {Text = "功能：上电解锁命令处理 说明：收到上电解锁二次命令时，区域封锁解封，所有道岔锁解锁 "} #end
    #pragma kcg separate_io #end PowerLockDelManage(
      inRegionBlockFlag : uint16;
      inElecPowerFlag : uint16;
      inRegionBlockPosition_S : RegionBlockPosition_Struct;
      inRevPowerLockCmdDataStru : PowerLockCommandData_Struct;
      inNumOfSwitch : uint16;
      inSwitchLockType_A : uint8^SWITCH_MAX;
      inSwitchELock_SA : SwitchELock_Struct^SWITCH_MAX;
      inNumOfSwitchSLock_A : uint16^SWITCH_MAX;
      inSwitchSLockFlag_AA : bool^SLOCK_MAX^SWITCH_MAX;
      inPhySecBlockIdFlag_A : uint8^PHYSEC_MAX)
    returns (
      outRegionBlockFlag : uint16 default = inRegionBlockFlag;
      outRegionBlockPosition_S
      : RegionBlockPosition_Struct
      default = inRegionBlockPosition_S;
      outElecPowerState : uint16 default = ELEC_NONE_OUT;
      outSwitchLockType_A : uint8^SWITCH_MAX default = inSwitchLockType_A;
      outSwitchELock_SA : SwitchELock_Struct^SWITCH_MAX default = inSwitchELock_SA;
      outNumOfSwitchSLock_A : uint16^SWITCH_MAX default = inNumOfSwitchSLock_A;
      outSwitchSLockFlag_AA
      : bool^SLOCK_MAX^SWITCH_MAX
      default = inSwitchSLockFlag_AA;
      outPhySecBlockIdFlag_A : uint8^PHYSEC_MAX default = inPhySecBlockIdFlag_A)
  let
    activate IfBlock1 if inElecPowerFlag #18 = ELEC_LOCK #5 and
      inRevPowerLockCmdDataStru#17.OC_ID #19 = g_OCNO
      then let
        activate IfBlock3 if inRevPowerLockCmdDataStru#8.OnceOrTwice #7 =
          ELEC_ONECE
          then var
            _L3 : uint16;
            _L4 : uint8;
            _L5 : uint8;
            _L6 : uint8;
            _L7 : uint16;
            _L8 : uint32;
          let
            _L3= ELEC_ONECE_OUT;
            outElecPowerState= _L3;
            _L4= #1 SetCiSendCmdBackInfoData(_L5, _L6, _L7, _L6, _L8);
            _L5= 0x01_ui8;
            _L6= 0_ui8;
            _L7= 0_ui16;
            _L8= inRevPowerLockCmdDataStru#18.CommandID;
            _= _L4;
            ()= #1 SetFirstCmdId(_L8);
          tel
          else if inRevPowerLockCmdDataStru#9.OnceOrTwice #8 = ELEC_TWICE
          then var
            L_firstCmdId : uint32;
            _L5 : uint32;
            _L10 : uint32;
            _L9 : uint8;
            _L8 : uint16;
            _L7 : uint8;
            _L6 : uint8;
          let
            activate IfBlock2 if inRevPowerLockCmdDataStru#19.CommandID #20 =
              L_firstCmdId
              then var
                _L4 : uint16;
                _L3 : uint16;
                _L2 : uint16;
                _L1 : RegionBlockPosition_Struct;
                _L5 : uint32;
                _L6 : uint8^PHYSEC_MAX;
              let
                outRegionBlockFlag= _L2;
                outElecPowerState= _L4;
                outRegionBlockPosition_S= _L1;
                _L1= (#2 make RegionBlockPosition_Struct)(_L3, _L3, _L3);
                _L2= REGION_UNBLOCK;
                _L3= REGION_UNBLOCK;
                _L4= ELEC_TWICE_OUT;
                activate IfBlock4 if inNumOfSwitch #3 > 0
                  then var
                    _L2 : uint8^SWITCH_MAX;
                    _L3 : SwitchELock_Struct^SWITCH_MAX;
                    _L4 : bool^SLOCK_MAX^SWITCH_MAX;
                    _L5 : uint16^SWITCH_MAX;
                  let
                    outSwitchLockType_A= _L2;
                    _L2= (0_ui8)#14^SWITCH_MAX;
                    outSwitchELock_SA= _L3;
                    _L3= (NULL_SwitchELock)#15^SWITCH_MAX;
                    outSwitchSLockFlag_AA= _L4;
                    _L4= ((false)#17^SLOCK_MAX)#16^SWITCH_MAX;
                    outNumOfSwitchSLock_A= _L5;
                    _L5= (0_ui16)#18^SWITCH_MAX;
                  tel
                  else let
                  tel
                returns ..;
                ()= #2 SetFirstCmdId(_L5);
                _L5= 0_ui32;
                outPhySecBlockIdFlag_A= _L6;
                _L6= (0_ui8)#21^PHYSEC_MAX;
              tel
              else let
              tel
            returns ..;
            _L5= #1 GetFirstCmdId();
            L_firstCmdId= _L5;
            _L6= 0_ui8;
            _= _L9;
            _L7= 0x02_ui8;
            _L8= 0_ui16;
            _L9= #2 SetCiSendCmdBackInfoData(_L7, _L6, _L8, _L6, _L10);
            _L10= inRevPowerLockCmdDataStru#20.CommandID;
          tel
          else let
          tel
        returns ..;
      tel
      else let
      tel
    returns ..;
  tel

  function imported #pragma kcg keep #end
    #pragma kcg separate_io #end SetCiSendCmdBackInfoData(
      inCommandType : uint8;
      inDeviceType : uint8;
      inDeviceId : uint16;
      inCommandParam : uint8;
      inCommandId : uint32)
    returns (outRetval : uint8);

  function imported GetFirstCmdId() returns (outRetVal : uint32);

  function imported #pragma kcg keep #end SetFirstCmdId(inCmdId : uint32)
    returns ();

end;


/* xscade source: E:/Work-TCT/6@VBTC_OC/0@SoftwareSource/OC_SCADE20190613/SignalCtrl.xscade */
package SignalCtrl
  function #pragma kcg expand #end
    #pragma kcg separate_io #end SignalOffCtrl_LightInvalidProc(
      inSignalState_S : SignalState_Struct;
      inSignalInfo_S : SignalInfo_Struct;
      inTMCLoseInputFlag : uint8;
      inTrainFlag_A : uint16^TRAIN_MAX;
      inTrainCommState_A : bool^TRAIN_MAX)
    returns (outSignalInfo_S : SignalInfo_Struct default = inSignalInfo_S)
  let
    activate IfBlock1 if inSignalInfo_S#16.SignalExpState #6 <> 0 #3 and
      inSignalInfo_S#17.SignalExpState #7 <> (inSignalState_S#18.State #2 : uint16)
      then let
        activate IfBlock2 if inSignalInfo_S#8.SignalCtrlTime #1 >
          SIGNAL_CTR_MAX_TIME
          then var
            _L7 : SignalInfo_Struct;
            _L6 : SignalInfo_Struct;
            _L5 : uint16;
            _L1 : uint16;
            _L2 : uint16;
            _L3 : uint16;
            _L4 : uint16;
          let
            _L1, _L2, _L3, _L4= (#3 flatten SignalInfo_Struct)(_L7);
            _L5= 0_ui16;
            _L6= (#3 make SignalInfo_Struct)(_L2, _L2, _L5, _L4);
            _L7= inSignalInfo_S;
            _= _L3;
            outSignalInfo_S= _L6;
            _= _L1;
          tel
          else var
            _L4 : uint16;
            _L5 : uint16;
            _L6 : uint16;
            _L7 : uint16;
            _L2 : SignalInfo_Struct;
            _L1 : SignalInfo_Struct;
            _L8 : uint16;
            _L9 : uint16;
          let
            _L1= (#2 make SignalInfo_Struct)(_L4, _L5, _L6, _L9);
            _L2= inSignalInfo_S;
            _L4, _L5, _L6, _L7= (#2 flatten SignalInfo_Struct)(_L2);
            outSignalInfo_S= _L1;
            _L8= 1_ui16;
            _L9= _L7 #2 + _L8;
          tel
        returns ..;
      tel
      else if inSignalInfo_S#19.SignalExpState #3 =
      (inSignalState_S#20.State #3 : uint16)
      then var
        _L1 : SignalInfo_Struct;
        _L5 : uint16;
        _L4 : uint16;
        _L3 : uint16;
        _L2 : uint16;
        _L6 : SignalInfo_Struct;
        _L7 : uint16;
      let
        _L1= inSignalInfo_S;
        _L5, _L4, _L3, _L2= (#1 flatten SignalInfo_Struct)(_L1);
        _L6= (#1 make SignalInfo_Struct)(_L5, _L4, _L3, _L7);
        _= _L2;
        _L7= 0_ui16;
        outSignalInfo_S= _L6;
      tel
      else let
      tel
    returns ..;
    activate IfBlock3 if outSignalInfo_S#10.SourceId #3 <> 0
      then let
        activate IfBlock2 if outSignalInfo_S#21.SourceId #4 = TMC_ID
          then let
            activate IfBlock4 if inTMCLoseInputFlag #2 >
              LOSE_TMC_INPUT_MAX_CYCLE
              then var
                probe NumOfCmd : uint16;
                _L3 : uint16;
                _L4 : uint16;
                _L5 : uint16;
                _L6 : uint32;
                _L7 : uint16;
              let
                _L3= outSignalInfo_S#3.SourceId;
                _L4= g_OCID;
                _L5= SIGNAL_RED;
                _L6= 0_ui32;
                _L7= #2 AddSignalCtrlCmd(_L4, _L3, _L5, _L6, _L6, _L6);
                NumOfCmd= _L7;
              tel
              else let
              tel
            returns ..;
          tel
          else var
            FindSignal : bool;
            _L1 : bool;
            _L3 : uint8;
            _L4 : uint16^TRAIN_MAX;
            _L5 : bool;
            _L6 : bool;
            _L10 : uint16^TRAIN_MAX;
            _L11 : bool^TRAIN_MAX;
          let
            _L3, _L1=
              (#2 foldw #1 FindSignalSource <<TRAIN_MAX>> if _L5)(_L6, _L10, _L11, _L4);
            _L4= (outSignalInfo_S#22.SourceId)#3^TRAIN_MAX;
            _L5= true;
            _L6= false;
            _= _L3;
            FindSignal= _L1;
            activate IfBlock4 if FindSignal
              then var
                probe NumOfCmd : uint16;
                _L5 : uint16;
                _L4 : uint16;
                _L3 : uint32;
                _L2 : uint16;
                _L1 : uint16;
              let
                _L1= SIGNAL_RED;
                _L2= #1 AddSignalCtrlCmd(_L5, _L4, _L1, _L3, _L3, _L3);
                _L3= 0_ui32;
                _L4= inSignalState_S#2.Id;
                _L5= g_OCID;
                NumOfCmd= _L2;
              tel
              else let
              tel
            returns ..;
            _L10= inTrainFlag_A;
            _L11= inTrainCommState_A;
          tel
        returns ..;
      tel
      else let
      tel
    returns ..;
  tel

  function SignalCtrl(
      inTMCLoseInputFlag : uint8;
      inCmdNumOfSignal : uint16;
      inRecvCmd_SA : Signal_SendCommandData_Struct^CMD_MAX;
      inNumOfSignal : uint16;
      inSignalState_SA : SignalState_Struct^SIGNAL_MAX;
      inSignalInfo_SA : SignalInfo_Struct^SIGNAL_MAX;
      inTrainFlag_A : uint16^TRAIN_MAX;
      inTrainCommState_A : bool^TRAIN_MAX)
    returns (outSignalInfo_SA : SignalInfo_Struct^SIGNAL_MAX)
  var
    _L6 : SignalState_Struct^SIGNAL_MAX;
    _L7 : SignalInfo_Struct^SIGNAL_MAX;
    _L16 : uint16;
    _L17 : bool;
    _L19 : Signal_SendCommandData_Struct^CMD_MAX^SIGNAL_MAX;
    _L20 : uint16^SIGNAL_MAX;
    _L21 : uint16^SIGNAL_MAX;
    _L25 : SignalInfo_Struct^SIGNAL_MAX;
    _L26 : uint8^SIGNAL_MAX;
    _L27 : uint16^TRAIN_MAX^SIGNAL_MAX;
    _L28 : bool^TRAIN_MAX^SIGNAL_MAX;
  let
    _L6= inSignalState_SA;
    _L7= inSignalInfo_SA;
    outSignalInfo_SA= _L25;
    _L16, _L25=
      (#2 mapwi
        #1 SignalCtrl_each
        <<SIGNAL_MAX>> if _L17 default (NULL_SignalInfo))(_L21, _L6, _L7, _L26,
        _L27, _L28, _L20, _L19);
    _L17= inNumOfSignal #1 > 0;
    _L19= (inRecvCmd_SA)#1^SIGNAL_MAX;
    _L20= (inCmdNumOfSignal)#2^SIGNAL_MAX;
    _L21= (inNumOfSignal)#3^SIGNAL_MAX;
    _= _L16;
    _L26= (inTMCLoseInputFlag)#5^SIGNAL_MAX;
    _L27= (inTrainFlag_A)#7^SIGNAL_MAX;
    _L28= (inTrainCommState_A)#9^SIGNAL_MAX;
  tel

  function #pragma kcg expand #end
    #pragma kcg separate_io #end SignalCmdProc_each(
      index : uint16;
      inFindSignal : int32;
      inNumOfCmd : uint16;
      inRecvCmd_S : Signal_SendCommandData_Struct;
      inSignalID : uint16;
      inSignalState : uint8)
    returns (outCondition : bool; outFindSignal : int32)
  var
    FindSignal : bool;
    _L2 : uint16;
    _L3 : bool;
    _L4 : uint16;
    _L5 : uint16;
    _L6 : uint16;
    _L7 : bool;
    _L9 : bool;
    _L10 : bool;
    _L11 : bool;
  let
    _L2= index #1 + 1;
    _L3= _L2 #1 < _L4;
    _L4= inNumOfCmd;
    outCondition= _L3;
    _L5= inRecvCmd_S#1.SignalID;
    _L6= inSignalID;
    _L7= _L6 #1 = _L5;
    _L9= inSignalState #1 <> 0xFF;
    _L10= inRecvCmd_S#2.SignalType #2 <> (inSignalState #1 : uint16);
    _L11= _L7 #1 and _L9 #1 and _L10;
    FindSignal= _L11;
    activate IfBlock1 if FindSignal
      then var
        _L1 : uint16;
        _L2 : Signal_SendCommandData_Struct;
        _L3 : int32;
      let
        _L1= #1 AddSignalCtrlCmd_S(_L2);
        _L2= inRecvCmd_S;
        _= _L1;
        outFindSignal= _L3;
        _L3= (index #2 : int32);
      tel
      else var
        _L1 : int32;
      let
        outFindSignal= _L1;
        _L1= inFindSignal;
      tel
    returns ..;
  tel

  function #pragma kcg expand #end
    #pragma kcg separate_io #end SignalCmdProc(
      inNumOfCmd : uint16;
      inRecvCmd_SA : Signal_SendCommandData_Struct^CMD_MAX;
      inSignalState_S : SignalState_Struct;
      inSignalInfo_S : SignalInfo_Struct)
    returns (outSignalInfo_S : SignalInfo_Struct default = inSignalInfo_S)
  var
    FindSignal : int32;
    _L4 : uint16;
    _L5 : bool;
    _L7 : bool;
    _L10 : uint16^CMD_MAX;
    _L15 : int32;
    _L17 : int32;
    _L18 : Signal_SendCommandData_Struct^CMD_MAX;
    _L19 : uint16^CMD_MAX;
    _L20 : uint8^CMD_MAX;
  let
    _L4, _L5, _L17=
      (#2 mapfoldwi 1 #1 SignalCmdProc_each <<CMD_MAX>> if _L7 default ())(_L15,
        _L10, _L18, _L19, _L20);
    _= _L4;
    _= _L5;
    _L7= inNumOfCmd #1 > 0;
    _L10= (inNumOfCmd)#1^CMD_MAX;
    activate IfBlock1 if FindSignal #3 <> - 1
      then var
        FindCmd : Signal_SendCommandData_Struct;
        _L21 : SignalInfo_Struct;
        _L22 : SignalInfo_Struct;
        _L26 : uint16;
        _L25 : uint16;
        _L24 : uint16;
        _L23 : uint16;
        _L27 : uint16;
        _L28 : uint16;
        _L29 : Signal_SendCommandData_Struct;
        _L30 : Signal_SendCommandData_Struct^CMD_MAX;
        _L31 : int32;
      let
        _L21= inSignalInfo_S;
        outSignalInfo_S= _L22;
        _L26, _L25, _L24, _L23= (#1 flatten SignalInfo_Struct)(_L21);
        _L22= (#1 make SignalInfo_Struct)(_L28, _L26, _L27, _L23);
        _L27= FindCmd#1.SignalType;
        _= _L24;
        _L28= FindCmd#2.SourceID;
        _= _L25;
        _L29= (_L30#1 . [_L31] default NULL_SignalCtrlCmdData);
        _L30= inRecvCmd_SA;
        _L31= FindSignal;
        FindCmd= _L29;
      tel
      else let
      tel
    returns ..;
    _L15= - 1;
    _L18= inRecvCmd_SA;
    _L19= (inSignalState_S#3.Id)#2^CMD_MAX;
    _L20= (inSignalState_S#4.State)#3^CMD_MAX;
    FindSignal= _L17;
  tel

  function imported #pragma kcg keep #end
    #pragma kcg C:name AddSignalCtrlCmd_S #end AddSignalCtrlCmd_S(
      CmdData : Signal_SendCommandData_Struct)
    returns (NumOfCmd : uint16);

  function imported #pragma kcg keep #end
    #pragma kcg C:name AddSignalCtrlCmd #end AddSignalCtrlCmd(
      SourceID : uint16;
      SignalID : uint16;
      SignalType : uint16;
      CommandID : uint32;
      TimeHigh : uint32;
      TimeLow : uint32)
    returns (NumOfCmd : uint16);

  function FindSignalSource(
      inAcc : bool;
      inTrainFlag : uint16;
      inTrainCommState : bool;
      inSignalSourceID : uint16)
    returns (outCondition : bool; outAcc : bool)
  var
    _L13 : bool;
    _L14 : bool;
    _L16 : bool;
    _L18 : bool;
    _L19 : bool;
  let
    _L13= #1 if _L18 then (_L14) else (_L16);
    outAcc= _L13;
    outCondition= _L19;
    _L14= true;
    _L16= inAcc;
    _L18=
      inTrainFlag #2 <> 0 #2 and #1 not inTrainCommState #2 and
      inTrainFlag #2 = inSignalSourceID;
    _L19= #2 not _L18;
  tel

  function #pragma kcg expand #end
    #pragma kcg separate_io #end SignalCtrl_each(
      index : uint16;
      inNumOfSignal : uint16;
      inSignalState_S : SignalState_Struct;
      inSignalInfo_S : SignalInfo_Struct;
      inTMCLoseInputFlag : uint8;
      inTrainFlag_A : uint16^TRAIN_MAX;
      inTrainCommState_A : bool^TRAIN_MAX;
      inNumOfCmd : uint16;
      inRecvCmd_SA : Signal_SendCommandData_Struct^CMD_MAX)
    returns (
      outCondition : bool;
      outSignalInfo_S : SignalInfo_Struct default = inSignalInfo_S)
  var
    _L1 : uint16;
    _L2 : bool;
    _L3 : uint16;
    _L5 : SignalInfo_Struct;
    _L7 : SignalInfo_Struct;
    _L8 : SignalState_Struct;
    _L9 : SignalInfo_Struct;
    _L10 : uint8;
    _L11 : uint16^TRAIN_MAX;
    _L12 : bool^TRAIN_MAX;
    _L13 : uint16;
    _L14 : Signal_SendCommandData_Struct^CMD_MAX;
    _L15 : SignalState_Struct;
  let
    _L1= index #1 + 1;
    _L2= _L1 #1 < _L3;
    _L3= inNumOfSignal;
    outCondition= _L2;
    _L5= #1 SignalOffCtrl_LightInvalidProc(_L8, _L9, _L10, _L11, _L12);
    _L7= #1 SignalCmdProc(_L13, _L14, _L15, _L5);
    _L8= inSignalState_S;
    _L9= inSignalInfo_S;
    _L10= inTMCLoseInputFlag;
    _L11= inTrainFlag_A;
    _L12= inTrainCommState_A;
    outSignalInfo_S= _L7;
    _L13= inNumOfCmd;
    _L14= inRecvCmd_SA;
    _L15= inSignalState_S;
  tel

end;


/* xscade source: E:/Work-TCT/6@VBTC_OC/0@SoftwareSource/OC_SCADE20190613/RegionBlockManage.xscade */
package RegionBlockManage
  function #pragma kcg doc "Graphical_1" {Text = "功能：区域封锁管理 说明：如果超过3周期未收到轨旁数据，执行区域封锁，否则，由收到的区域封锁命令决定是否执行区域封锁 "} #end
    RegionBlockManage(
      inNumOfRegionBlockCmd : uint16;
      inRecvRegionBlockCmd_SA : Region_Block_CommandData_Struct^CMD_MAX;
      inRegionBlockFlag : uint16;
      inRegionBlockPosition_S : RegionBlockPosition_Struct;
      inWSLoseInputFlag : uint8)
    returns (
      outRegionBlockFlag : uint16;
      outRegionBlockPosition_S
      : RegionBlockPosition_Struct
      default = inRegionBlockPosition_S)
  let
    activate IfBlock1 if inWSLoseInputFlag #2 > LOSE_WS_INPUT_MAX_CYCLE
      then var
        _L1 : uint16;
      let
        outRegionBlockFlag= _L1;
        _L1= REGION_BLOCK;
      tel
      else var
        L_up : uint16;
        L_down : uint16;
        _L7 : Region_Block_CommandData_Struct^CMD_MAX;
        _L6 : bool;
        _L5 : uint16;
        _L3 : uint16;
        _L2 : uint16^CMD_MAX;
        _L9 : uint16;
        _L8 : bool;
        _L10 : RegionBlockPosition_Struct;
        _L11 : RegionBlockPosition_Struct;
        _L14 : uint16;
        _L15 : RegionBlockPosition_Struct;
        _L16 : bool;
        _L17 : uint16;
        _L18 : uint16;
      let
        outRegionBlockFlag= _L9;
        _L2= (inNumOfRegionBlockCmd)#2^CMD_MAX;
        _L3, _L8, _L9, _L10=
          (#3 mapfoldwi 2 #2 RegionBlockManage_each <<CMD_MAX>> if _L6 default ())(_L5,
            _L11, _L2, _L7);
        _L5= inRegionBlockFlag;
        _= _L3;
        _L6= inNumOfRegionBlockCmd #3 > 0;
        _L7= inRecvRegionBlockCmd_SA;
        _= _L8;
        _L11= inRegionBlockPosition_S;
        outRegionBlockPosition_S= _L15;
        _L14, L_up, L_down= (#1 flatten RegionBlockPosition_Struct)(_L10);
        _L15= (#1 make RegionBlockPosition_Struct)(_L17, L_up, L_down);
        _L16= L_up #1 = REGION_BLOCK #1 and L_down #2 = REGION_BLOCK;
        _L17= #1 if _L16 then (_L18) else (_L14);
        _L18= REGION_BLOCK;
      tel
    returns ..;
  tel

  function #pragma kcg expand #end
    #pragma kcg separate_io #end RegionBlockManage_each(
      index : uint16;
      inRegionBlockFlag : uint16;
      inRegionBlockPosition_S : RegionBlockPosition_Struct;
      inNumOfCmd : uint16;
      inRecvCmd_S : Region_Block_CommandData_Struct)
    returns (
      outCondition : bool;
      outRegionBlockFlag : uint16 default = inRegionBlockFlag;
      outRegionBlockPosition_S
      : RegionBlockPosition_Struct
      default = inRegionBlockPosition_S)
  var
    _L1 : bool;
  let
    _L1= index #1 + 1 #1 < inNumOfCmd;
    outCondition= _L1;
    activate IfBlock2 if inRecvCmd_S#15.BlockLable #7 = REGION_BLOCK_SET
      then let
        activate IfBlock1 if inRecvCmd_S#18.Region #10 = 0xff
          then var
            _L5 : uint16;
            _L6 : RegionBlockPosition_Struct;
            _L7 : RegionBlockPosition_Struct;
            _L10 : uint16;
            _L9 : uint16;
            _L8 : uint16;
            _L19 : uint16;
            _L20 : uint16;
            _L22 : uint16;
          let
            outRegionBlockFlag= _L5;
            _L5= REGION_BLOCK;
            _L6= inRegionBlockPosition_S;
            _L7= (#1 make RegionBlockPosition_Struct)(_L19, _L20, _L22);
            _L10, _L9, _L8= (#1 flatten RegionBlockPosition_Struct)(_L6);
            _= _L10;
            _L19= REGION_BLOCK;
            outRegionBlockPosition_S= _L7;
            _= _L9;
            _= _L8;
            _L20= REGION_BLOCK;
            _L22= REGION_BLOCK;
          tel
          else if inRecvCmd_S#19.Region #11 = 0x55
          then var
            _L7 : uint16;
            _L6 : RegionBlockPosition_Struct;
            _L5 : uint16;
            _L2 : uint16;
            _L3 : uint16;
            _L4 : uint16;
            _L1 : RegionBlockPosition_Struct;
          let
            _L1= inRegionBlockPosition_S;
            outRegionBlockFlag= _L7;
            _L2, _L3, _L4= (#4 flatten RegionBlockPosition_Struct)(_L1);
            _L5= REGION_BLOCK;
            _L6= (#4 make RegionBlockPosition_Struct)(_L2, _L5, _L4);
            _L7= REGION_BLOCK;
            _= _L3;
            outRegionBlockPosition_S= _L6;
          tel
          else if inRecvCmd_S#20.Region #12 = 0xaa
          then var
            _L7 : uint16;
            _L6 : RegionBlockPosition_Struct;
            _L3 : uint16;
            _L4 : uint16;
            _L5 : uint16;
            _L2 : uint16;
            _L1 : RegionBlockPosition_Struct;
          let
            _L1= inRegionBlockPosition_S;
            _= _L5;
            outRegionBlockPosition_S= _L6;
            outRegionBlockFlag= _L2;
            _L2= REGION_BLOCK;
            _L3, _L4, _L5= (#5 flatten RegionBlockPosition_Struct)(_L1);
            _L6= (#5 make RegionBlockPosition_Struct)(_L3, _L4, _L7);
            _L7= REGION_BLOCK;
          tel
          else let
          tel
        returns ..;
      tel
      else if inRecvCmd_S#17.BlockLable #9 = REGION_BLOCK_RELIEVE
      then let
        activate IfBlock1 if inRecvCmd_S#23.Region #13 = 0xff
          then var
            _L5 : uint16;
            _L6 : RegionBlockPosition_Struct;
            _L7 : RegionBlockPosition_Struct;
            _L10 : uint16;
            _L9 : uint16;
            _L8 : uint16;
            _L19 : uint16;
            _L20 : uint16;
            _L22 : uint16;
          let
            outRegionBlockFlag= _L5;
            _L5= REGION_UNBLOCK;
            _L6= inRegionBlockPosition_S;
            _L7= (#8 make RegionBlockPosition_Struct)(_L19, _L20, _L22);
            _L10, _L9, _L8= (#8 flatten RegionBlockPosition_Struct)(_L6);
            _= _L10;
            _L19= REGION_UNBLOCK;
            outRegionBlockPosition_S= _L7;
            _= _L9;
            _= _L8;
            _L20= REGION_UNBLOCK;
            _L22= REGION_UNBLOCK;
          tel
          else if inRecvCmd_S#24.Region #14 = 0x55
          then var
            _L7 : uint16;
            _L6 : RegionBlockPosition_Struct;
            _L5 : uint16;
            _L2 : uint16;
            _L3 : uint16;
            _L4 : uint16;
            _L1 : RegionBlockPosition_Struct;
            _L8 : uint16;
          let
            _L1= inRegionBlockPosition_S;
            outRegionBlockFlag= _L7;
            _L2, _L3, _L4= (#7 flatten RegionBlockPosition_Struct)(_L1);
            _L5= REGION_UNBLOCK;
            _L6= (#7 make RegionBlockPosition_Struct)(_L8, _L5, _L4);
            _L7= REGION_UNBLOCK;
            _= _L3;
            outRegionBlockPosition_S= _L6;
            _= _L2;
            _L8= REGION_UNBLOCK;
          tel
          else if inRecvCmd_S#25.Region #15 = 0xaa
          then var
            _L7 : uint16;
            _L6 : RegionBlockPosition_Struct;
            _L3 : uint16;
            _L4 : uint16;
            _L5 : uint16;
            _L2 : uint16;
            _L1 : RegionBlockPosition_Struct;
            _L8 : uint16;
          let
            _L1= inRegionBlockPosition_S;
            _= _L5;
            outRegionBlockPosition_S= _L6;
            outRegionBlockFlag= _L2;
            _L2= REGION_UNBLOCK;
            _L3, _L4, _L5= (#6 flatten RegionBlockPosition_Struct)(_L1);
            _L6= (#6 make RegionBlockPosition_Struct)(_L8, _L4, _L7);
            _L7= REGION_UNBLOCK;
            _= _L3;
            _L8= REGION_UNBLOCK;
          tel
          else let
          tel
        returns ..;
      tel
      else let
      tel
    returns ..;
  tel

end;


/* xscade source: E:/Work-TCT/6@VBTC_OC/0@SoftwareSource/OC_SCADE20190613/Lock_SwitchCommandInvalidManage.xscade */
package Lock_SwitchCommandInvalidManage
  function CmdValidityManage(
      inNumOfCmdATSLock : uint16;
      inCmdATSLock_SA : ATSLock_CommandData_Struct^CMD_MAX;
      inNumOfCmdVOBCLock : uint16;
      inCmdVOBCLock_SA : VOBCLock_CommandData_Struct^CMD_MAX;
      inNumOfCmdTMCLock : uint16;
      inCmdTMCLock_SA : VOBCLock_CommandData_Struct^CMD_MAX;
      inNumOfCmdHCOCLock : uint16;
      inCmdHCOCLock_SA : ATSLock_CommandData_Struct^CMD_MAX;
      inNumOfCmdSwitch : uint16;
      inCmdSwitch_SA : Switch_CommandData_Struct^CMD_MAX;
      inATSLockDelCountDown_SA : ATSLockDelete_CountDown_Struct^CMD_MAX;
      inNumOfSwitch : uint16;
      inSwitchState_SA : SwitchState_Struct^SWITCH_MAX;
      inSwitchFaultState_A : uint8^SWITCH_MAX)
    returns (
      outNumOfCmdATSLock : uint16;
      outCmdATSLockFlag_A : bool^CMD_MAX;
      outNumOfCmdHCOCLock : uint16;
      outCmdHCOCLockFlag_A : bool^CMD_MAX;
      outNumOfCmdVOBCLock : uint16;
      outCmdVOBCLockFlag_A : bool^CMD_MAX;
      outNumOfCmdTMCLock : uint16;
      outCmdTMCLockFlag_A : bool^CMD_MAX;
      outNumOfCmdSwitch : uint16;
      outCmdSwitchFlag_A : bool^CMD_MAX)
  var
    _L4 : bool^CMD_MAX;
    _L3 : uint16;
    _L8 : uint16;
    _L9 : uint16;
    _L10 : ATSLockDelete_CountDown_Struct^CMD_MAX;
    _L12 : ATSLock_CommandData_Struct^CMD_MAX;
    _L13 : SwitchState_Struct^SWITCH_MAX;
    _L14 : uint8^SWITCH_MAX;
    _L24 : uint8^SWITCH_MAX;
    _L23 : SwitchState_Struct^SWITCH_MAX;
    _L22 : VOBCLock_CommandData_Struct^CMD_MAX;
    _L20 : ATSLockDelete_CountDown_Struct^CMD_MAX;
    _L19 : uint16;
    _L18 : uint16;
    _L16 : bool^CMD_MAX;
    _L15 : uint16;
    _L34 : uint8^SWITCH_MAX;
    _L33 : SwitchState_Struct^SWITCH_MAX;
    _L32 : VOBCLock_CommandData_Struct^CMD_MAX;
    _L30 : ATSLockDelete_CountDown_Struct^CMD_MAX;
    _L29 : uint16;
    _L28 : uint16;
    _L26 : bool^CMD_MAX;
    _L25 : uint16;
    _L42 : ATSLock_CommandData_Struct^CMD_MAX;
    _L40 : ATSLockDelete_CountDown_Struct^CMD_MAX;
    _L38 : uint16;
    _L36 : bool^CMD_MAX;
    _L35 : uint16;
    _L54 : uint8^SWITCH_MAX;
    _L53 : SwitchState_Struct^SWITCH_MAX;
    _L52 : Switch_CommandData_Struct^CMD_MAX;
    _L50 : ATSLockDelete_CountDown_Struct^CMD_MAX;
    _L49 : uint16;
    _L48 : uint16;
    _L46 : bool^CMD_MAX;
    _L45 : uint16;
  let
    _L3, _L4= #2 ATSLockCmdValidityManage(_L8, _L9, _L10, _L12, _L13, _L14);
    outNumOfCmdATSLock= _L3;
    outCmdATSLockFlag_A= _L4;
    _L8= inNumOfCmdATSLock;
    _L9= inNumOfSwitch;
    _L10= inATSLockDelCountDown_SA;
    _L12= inCmdATSLock_SA;
    _L13= inSwitchState_SA;
    _L14= inSwitchFaultState_A;
    _L24= inSwitchFaultState_A;
    _L23= inSwitchState_SA;
    _L22= inCmdTMCLock_SA;
    _L20= inATSLockDelCountDown_SA;
    _L19= inNumOfSwitch;
    _L18= inNumOfCmdTMCLock;
    outCmdTMCLockFlag_A= _L16;
    outNumOfCmdTMCLock= _L15;
    _L15, _L16=
      #1 VOBCorTMCLockCmdValidityManage(_L18, _L19, _L20, _L22, _L23, _L24);
    _L34= inSwitchFaultState_A;
    _L33= inSwitchState_SA;
    _L32= inCmdVOBCLock_SA;
    _L30= inATSLockDelCountDown_SA;
    _L29= inNumOfSwitch;
    _L28= inNumOfCmdVOBCLock;
    outCmdVOBCLockFlag_A= _L26;
    outNumOfCmdVOBCLock= _L25;
    _L25, _L26=
      #2 VOBCorTMCLockCmdValidityManage(_L28, _L29, _L30, _L32, _L33, _L34);
    _L42= inCmdHCOCLock_SA;
    _L40= inATSLockDelCountDown_SA;
    _L38= inNumOfCmdHCOCLock;
    outCmdHCOCLockFlag_A= _L36;
    outNumOfCmdHCOCLock= _L35;
    _L35, _L36= #2 HCOCLockCmdValidityManage(_L38, _L40, _L42);
    _L54= inSwitchFaultState_A;
    _L53= inSwitchState_SA;
    _L52= inCmdSwitch_SA;
    _L50= inATSLockDelCountDown_SA;
    _L49= inNumOfSwitch;
    _L48= inNumOfCmdSwitch;
    outCmdSwitchFlag_A= _L46;
    outNumOfCmdSwitch= _L45;
    _L45, _L46= #1 SwitchCmdValidityManage(_L48, _L49, _L50, _L52, _L53, _L54);
  tel

  function #pragma kcg expand #end
    #pragma kcg separate_io #end VOBCorTMCLockCmdValidityManage(
      inNumOfCmdLock : uint16;
      inNumOfSwitch : uint16;
      inATSLockDelCountDown_SA : ATSLockDelete_CountDown_Struct^CMD_MAX;
      inCmdLock_SA : VOBCLock_CommandData_Struct^CMD_MAX;
      inSwitchState_SA : SwitchState_Struct^SWITCH_MAX;
      inSwitchFaultState_A : uint8^SWITCH_MAX)
    returns (outNumOfCmdLock : uint16; outCmdLockFlag_A : bool^CMD_MAX)
  var
    _L2 : uint16;
    _L3 : uint16;
    _L4 : bool;
    _L5 : bool;
    _L6 : uint16;
    _L8 : uint16^CMD_MAX;
    _L9 : ATSLockDelete_CountDown_Struct^CMD_MAX^CMD_MAX;
    _L10 : VOBCLock_CommandData_Struct^CMD_MAX;
    _L11 : bool^CMD_MAX;
    _L12 : uint16^CMD_MAX;
    _L13 : SwitchState_Struct^SWITCH_MAX^CMD_MAX;
    _L16 : uint8^SWITCH_MAX^CMD_MAX;
  let
    _L3, _L4, _L2, _L11=
      (#1 mapfoldwi 1
        #1 VOBCorTMCLockCmdValidityManage_each
        <<CMD_MAX>> if _L5 default (false))(_L6, _L12, _L8, _L9, _L13, _L16,
        _L10);
    _L5= inNumOfCmdLock #1 > 0;
    _L6= inNumOfCmdLock;
    outNumOfCmdLock= _L2;
    _= _L3;
    _= _L4;
    _L8= (inNumOfCmdLock)#3^CMD_MAX;
    _L9= (inATSLockDelCountDown_SA)#5^CMD_MAX;
    _L10= inCmdLock_SA;
    outCmdLockFlag_A= _L11;
    _L12= (inNumOfSwitch)#13^CMD_MAX;
    _L13= (inSwitchState_SA)#11^CMD_MAX;
    _L16= (inSwitchFaultState_A)#12^CMD_MAX;
  tel

  function VOBCorTMCLockCmdValidityManage_each(
      index : uint16;
      inOldNumOfCmd : uint16;
      inNumOfSwitch : uint16;
      inNumOfCmdLock : uint16;
      inATSLockDelCountDown_SA : ATSLockDelete_CountDown_Struct^CMD_MAX;
      inSwitchState_SA : SwitchState_Struct^SWITCH_MAX;
      inSwitchFaultState_A : uint8^SWITCH_MAX;
      inCmdLock_S : VOBCLock_CommandData_Struct)
    returns (outCondition : bool; outNewNumOfCmd : uint16; outFlag : bool)
  var
    _L6 : bool;
    _L8 : ATSLockDelete_CountDown_Struct^CMD_MAX;
    _L10 : uint16^CMD_MAX;
    _L11 : bool;
    _L12 : uint16;
    _L15 : uint16;
    _L18 : uint16;
    _L19 : bool;
    _L22 : bool;
    _L23 : uint16^SWITCH_MAX;
    _L24 : uint16^SWITCH_MAX;
    _L25 : SwitchState_Struct^SWITCH_MAX;
    _L26 : uint8^SWITCH_MAX;
    _L27 : bool;
    _L31 : uint16;
    _L30 : uint16;
    _L29 : uint16;
    _L28 : bool;
    _L37 : bool;
  let
    _L37= (#1 fold #1 LockCmdIsValidByATS <<CMD_MAX>>)(_L6, _L8, _L10);
    _L6= true;
    _L8= inATSLockDelCountDown_SA;
    _L10= (inCmdLock_S#2.SwitchID)#2^CMD_MAX;
    _L11= index #1 + 1 #1 < inNumOfCmdLock;
    outCondition= _L11;
    _L12= #1 if _L27 then (_L31) else (_L15);
    outNewNumOfCmd= _L12;
    _L15= inOldNumOfCmd;
    _L18, _L19=
      (#5 foldwi #1 LockCmdIsValidBySwitch <<SWITCH_MAX>> if _L22)(_L37, _L23,
        _L25, _L26, _L24);
    outFlag= _L19;
    _L22= inNumOfSwitch #2 > 0;
    _L23= (inNumOfSwitch)#5^SWITCH_MAX;
    _L24= (inCmdLock_S#4.SwitchID)#7^SWITCH_MAX;
    _L25= inSwitchState_SA;
    _L26= inSwitchFaultState_A;
    _L27= #2 not _L19;
    _= _L18;
    _L28= inOldNumOfCmd #3 > 0;
    _L29= 0_ui16;
    _L30= inOldNumOfCmd #2 - 1;
    _L31= #2 if _L28 then (_L30) else (_L29);
  tel

  function LockCmdIsValidByATS(
      inAcc : bool;
      inATSLockDelCountDown_S : ATSLockDelete_CountDown_Struct;
      inCmdSwitchID : uint16)
    returns (outCmdIsValid : bool)
  var
    _L1 : bool;
    _L3 : bool;
    _L5 : bool;
    _L9 : bool;
  let
    _L1=
      inATSLockDelCountDown_S#5.SwitchID_ATSQingLing #1 = 0 #1 or
      inCmdSwitchID #4 <> inATSLockDelCountDown_S#6.SwitchID_ATSQingLing;
    _L3= #1 if _L1 then (_L9) else (_L5);
    _L5= false;
    outCmdIsValid= _L3;
    _L9= inAcc;
  tel

  function LockCmdIsValidBySwitch(
      index : uint16;
      inAcc : bool;
      inNumOfSwitch : uint16;
      inSwitchState_S : SwitchState_Struct;
      inSwitchFaultState : uint8;
      inCmdSwitchID : uint16)
    returns (outCondition : bool; outCmdIsValid : bool)
  var
    _L1 : bool;
    _L3 : bool;
    _L4 : bool;
    _L6 : bool;
    _L7 : bool;
    _L9 : bool;
    _L10 : bool;
  let
    _L1=
      inCmdSwitchID #2 = inSwitchState_S#3.Id #2 and
      inSwitchFaultState #3 = SWITCH_FAULT;
    _L3= #1 if _L1 then (_L4) else (_L9);
    _L4= false;
    outCmdIsValid= _L3;
    _L6= index #1 + 1 #1 < inNumOfSwitch;
    _L7= _L6 #1 and _L10;
    outCondition= _L7;
    _L9= inAcc;
    _L10= #1 not _L1;
  tel

  function HCOCLockCmdValidityManage_each(
      index : uint16;
      inOldNumOfCmd : uint16;
      inNumOfCmdLock : uint16;
      inATSLockDelCountDown_SA : ATSLockDelete_CountDown_Struct^CMD_MAX;
      inCmdLock_S : ATSLock_CommandData_Struct)
    returns (outCondition : bool; outNewNumOfCmd : uint16; outFlag : bool)
  var
    _L6 : bool;
    _L8 : ATSLockDelete_CountDown_Struct^CMD_MAX;
    _L10 : uint16^CMD_MAX;
    _L11 : bool;
    _L12 : uint16;
    _L14 : bool;
    _L15 : uint16;
    _L27 : bool;
    _L28 : uint16;
    _L29 : uint16;
    _L30 : uint16;
    _L36 : bool;
  let
    _L36= (#2 fold #1 LockCmdIsValidByATS <<CMD_MAX>>)(_L6, _L8, _L10);
    _L6= true;
    _L8= inATSLockDelCountDown_SA;
    _L10= (inCmdLock_S#1.SwitchID)#2^CMD_MAX;
    _L11= index #1 + 1 #1 < inNumOfCmdLock;
    outCondition= _L11;
    _L12= #1 if _L27 then (_L29) else (_L15);
    outNewNumOfCmd= _L12;
    _L14= inOldNumOfCmd #2 > 0;
    _L15= inOldNumOfCmd;
    outFlag= _L36;
    _L27= #1 not _L36;
    _L28= inOldNumOfCmd #2 - 1;
    _L29= #2 if _L14 then (_L28) else (_L30);
    _L30= 0_ui16;
  tel

  function #pragma kcg expand #end
    #pragma kcg separate_io #end HCOCLockCmdValidityManage(
      inNumOfCmdLock : uint16;
      inATSLockDelCountDown_SA : ATSLockDelete_CountDown_Struct^CMD_MAX;
      inCmdLock_SA : ATSLock_CommandData_Struct^CMD_MAX)
    returns (outNumOfCmdLock : uint16; outCmdLockFlag_A : bool^CMD_MAX)
  var
    _L2 : uint16;
    _L3 : uint16;
    _L4 : bool;
    _L5 : bool;
    _L6 : uint16;
    _L8 : uint16^CMD_MAX;
    _L9 : ATSLockDelete_CountDown_Struct^CMD_MAX^CMD_MAX;
    _L10 : ATSLock_CommandData_Struct^CMD_MAX;
    _L11 : bool^CMD_MAX;
  let
    _L3, _L4, _L2, _L11=
      (#2 mapfoldwi 1
        #1 HCOCLockCmdValidityManage_each
        <<CMD_MAX>> if _L5 default (false))(_L6, _L8, _L9, _L10);
    _L5= inNumOfCmdLock #1 > 0;
    _L6= inNumOfCmdLock;
    outNumOfCmdLock= _L2;
    _= _L3;
    _= _L4;
    _L8= (inNumOfCmdLock)#2^CMD_MAX;
    _L9= (inATSLockDelCountDown_SA)#3^CMD_MAX;
    _L10= inCmdLock_SA;
    outCmdLockFlag_A= _L11;
  tel

  function ATSLockCmdValidityManage_each(
      index : uint16;
      inOldNumOfCmd : uint16;
      inNumOfSwitch : uint16;
      inNumOfCmdLock : uint16;
      inATSLockDelCountDown_SA : ATSLockDelete_CountDown_Struct^CMD_MAX;
      inSwitchState_SA : SwitchState_Struct^SWITCH_MAX;
      inSwitchFaultState_A : uint8^SWITCH_MAX;
      inCmdLock_S : ATSLock_CommandData_Struct)
    returns (outCondition : bool; outNewNumOfCmd : uint16; outFlag : bool)
  var
    _L6 : bool;
    _L8 : ATSLockDelete_CountDown_Struct^CMD_MAX;
    _L10 : uint16^CMD_MAX;
    _L11 : bool;
    _L12 : uint16;
    _L15 : uint16;
    _L18 : uint16;
    _L19 : bool;
    _L22 : bool;
    _L23 : uint16^SWITCH_MAX;
    _L24 : uint16^SWITCH_MAX;
    _L25 : SwitchState_Struct^SWITCH_MAX;
    _L26 : uint8^SWITCH_MAX;
    _L27 : bool;
    _L31 : uint16;
    _L30 : uint16;
    _L29 : uint16;
    _L28 : bool;
  let
    _L6= true;
    _L8= inATSLockDelCountDown_SA;
    _L10= (inCmdLock_S#1.SwitchID)#2^CMD_MAX;
    _L11= index #1 + 1 #1 < inNumOfCmdLock;
    outCondition= _L11;
    _L12= #1 if _L27 then (_L31) else (_L15);
    outNewNumOfCmd= _L12;
    _L15= inOldNumOfCmd;
    _L18, _L19=
      (#4 foldwi #1 LockCmdIsValidBySwitch <<SWITCH_MAX>> if _L22)(_L6, _L23,
        _L25, _L26, _L24);
    outFlag= _L19;
    _L22= inNumOfSwitch #2 > 0;
    _L23= (inNumOfSwitch)#3^SWITCH_MAX;
    _L24= (inCmdLock_S#2.SwitchID)#4^SWITCH_MAX;
    _L25= inSwitchState_SA;
    _L26= inSwitchFaultState_A;
    _L27= #1 not _L19;
    _= _L18;
    _L28= inOldNumOfCmd #3 > 0;
    _L29= 0_ui16;
    _L30= inOldNumOfCmd #2 - 1;
    _L31= #2 if _L28 then (_L30) else (_L29);
    _= _L8;
    _= _L10;
  tel

  function #pragma kcg expand #end
    #pragma kcg separate_io #end ATSLockCmdValidityManage(
      inNumOfCmdLock : uint16;
      inNumOfSwitch : uint16;
      inATSLockDelCountDown_SA : ATSLockDelete_CountDown_Struct^CMD_MAX;
      inCmdLock_SA : ATSLock_CommandData_Struct^CMD_MAX;
      inSwitchState_SA : SwitchState_Struct^SWITCH_MAX;
      inSwitchFaultState_A : uint8^SWITCH_MAX)
    returns (outNumOfCmdLock : uint16; outCmdLockFlag_A : bool^CMD_MAX)
  var
    _L2 : uint16;
    _L3 : uint16;
    _L4 : bool;
    _L5 : bool;
    _L6 : uint16;
    _L8 : uint16^CMD_MAX;
    _L9 : ATSLockDelete_CountDown_Struct^CMD_MAX^CMD_MAX;
    _L10 : ATSLock_CommandData_Struct^CMD_MAX;
    _L11 : bool^CMD_MAX;
    _L12 : uint16^CMD_MAX;
    _L13 : SwitchState_Struct^SWITCH_MAX^CMD_MAX;
    _L16 : uint8^SWITCH_MAX^CMD_MAX;
  let
    _L3, _L4, _L2, _L11=
      (#2 mapfoldwi 1
        #1 ATSLockCmdValidityManage_each
        <<CMD_MAX>> if _L5 default (false))(_L6, _L12, _L8, _L9, _L13, _L16,
        _L10);
    _L5= inNumOfCmdLock #1 > 0;
    _L6= inNumOfCmdLock;
    outNumOfCmdLock= _L2;
    _= _L3;
    _= _L4;
    _L8= (inNumOfCmdLock)#2^CMD_MAX;
    _L9= (inATSLockDelCountDown_SA)#3^CMD_MAX;
    _L10= inCmdLock_SA;
    outCmdLockFlag_A= _L11;
    _L12= (inNumOfSwitch)#4^CMD_MAX;
    _L13= (inSwitchState_SA)#5^CMD_MAX;
    _L16= (inSwitchFaultState_A)#6^CMD_MAX;
  tel

  function SwitchCmdValidityManage_each(
      index : uint16;
      inOldNumOfCmd : uint16;
      inNumOfSwitch : uint16;
      inNumOfCmdLock : uint16;
      inATSLockDelCountDown_SA : ATSLockDelete_CountDown_Struct^CMD_MAX;
      inSwitchState_SA : SwitchState_Struct^SWITCH_MAX;
      inSwitchFaultState_A : uint8^SWITCH_MAX;
      inCmdSwitch_S : Switch_CommandData_Struct)
    returns (outCondition : bool; outNewNumOfCmd : uint16; outFlag : bool)
  var
    _L6 : bool;
    _L8 : ATSLockDelete_CountDown_Struct^CMD_MAX;
    _L10 : uint16^CMD_MAX;
    _L11 : bool;
    _L12 : uint16;
    _L15 : uint16;
    _L18 : uint16;
    _L19 : bool;
    _L22 : bool;
    _L23 : uint16^SWITCH_MAX;
    _L24 : uint16^SWITCH_MAX;
    _L25 : SwitchState_Struct^SWITCH_MAX;
    _L26 : uint8^SWITCH_MAX;
    _L27 : bool;
    _L31 : uint16;
    _L30 : uint16;
    _L29 : uint16;
    _L28 : bool;
    _L37 : bool;
  let
    _L37= (#2 fold #1 LockCmdIsValidByATS <<CMD_MAX>>)(_L6, _L8, _L10);
    _L6= true;
    _L8= inATSLockDelCountDown_SA;
    _L10= (inCmdSwitch_S#1.SwitchID)#2^CMD_MAX;
    _L11= index #1 + 1 #1 < inNumOfCmdLock;
    outCondition= _L11;
    _L12= #1 if _L27 then (_L30) else (_L15);
    outNewNumOfCmd= _L12;
    _L15= inOldNumOfCmd;
    _L18, _L19=
      (#4 foldwi #1 LockCmdIsValidBySwitch <<SWITCH_MAX>> if _L22)(_L37, _L23,
        _L25, _L26, _L24);
    outFlag= _L19;
    _L22= inNumOfSwitch #2 > 0;
    _L23= (inNumOfSwitch)#3^SWITCH_MAX;
    _L24= (inCmdSwitch_S#2.SwitchID)#4^SWITCH_MAX;
    _L25= inSwitchState_SA;
    _L26= inSwitchFaultState_A;
    _L27= #1 not _L19;
    _= _L18;
    _L28= inOldNumOfCmd #3 > 0;
    _L29= 0_ui16;
    _L30= #2 if _L28 then (_L31) else (_L29);
    _L31= inOldNumOfCmd #2 - 1;
  tel

  function #pragma kcg expand #end
    #pragma kcg separate_io #end SwitchCmdValidityManage(
      inNumOfCmdLock : uint16;
      inNumOfSwitch : uint16;
      inATSLockDelCountDown_SA : ATSLockDelete_CountDown_Struct^CMD_MAX;
      inCmdSwitch_SA : Switch_CommandData_Struct^CMD_MAX;
      inSwitchState_SA : SwitchState_Struct^SWITCH_MAX;
      inSwitchFaultState_A : uint8^SWITCH_MAX)
    returns (outNumOfCmdLock : uint16; outCmdLockFlag_A : bool^CMD_MAX)
  var
    _L2 : uint16;
    _L3 : uint16;
    _L4 : bool;
    _L5 : bool;
    _L6 : uint16;
    _L8 : uint16^CMD_MAX;
    _L9 : ATSLockDelete_CountDown_Struct^CMD_MAX^CMD_MAX;
    _L10 : Switch_CommandData_Struct^CMD_MAX;
    _L11 : bool^CMD_MAX;
    _L12 : uint16^CMD_MAX;
    _L13 : SwitchState_Struct^SWITCH_MAX^CMD_MAX;
    _L16 : uint8^SWITCH_MAX^CMD_MAX;
  let
    _L3, _L4, _L2, _L11=
      (#2 mapfoldwi 1
        #1 SwitchCmdValidityManage_each
        <<CMD_MAX>> if _L5 default (false))(_L6, _L12, _L8, _L9, _L13, _L16,
        _L10);
    _L5= inNumOfCmdLock #1 > 0;
    _L6= inNumOfCmdLock;
    outNumOfCmdLock= _L2;
    _= _L3;
    _= _L4;
    _L8= (inNumOfCmdLock)#2^CMD_MAX;
    _L9= (inATSLockDelCountDown_SA)#3^CMD_MAX;
    _L10= inCmdSwitch_SA;
    outCmdLockFlag_A= _L11;
    _L12= (inNumOfSwitch)#4^CMD_MAX;
    _L13= (inSwitchState_SA)#5^CMD_MAX;
    _L16= (inSwitchFaultState_A)#6^CMD_MAX;
  tel

end;


/* xscade source: E:/Work-TCT/6@VBTC_OC/0@SoftwareSource/OC_SCADE20190613/TrainManage.xscade */
package TrainManage
  function #pragma kcg doc "Graphical_1" {Text = "在列车表中查找列车，如果找到返回存储的位置索引，否则返回-1"} #end
    GetIndexByTrainId(inTrainFlag_A : uint16^TRAIN_MAX; inTrainId : uint16)
    returns (outFindIndex : int32)
  var
    _L1 : int32;
    _L3 : int32;
    _L4 : bool;
    _L5 : int32;
    _L7 : uint16^TRAIN_MAX;
    _L8 : uint16^TRAIN_MAX;
  let
    _L3, _L1=
      (#1 foldwi #1 GetIndexByTrainId_each <<TRAIN_MAX>> if _L4)(_L5, _L8, _L7);
    _L4= true;
    _L5= - 1;
    _L7= (inTrainId)#1^TRAIN_MAX;
    _= _L3;
    outFindIndex= _L1;
    _L8= inTrainFlag_A;
  tel

  function #pragma kcg expand #end GetIndexByTrainId_each(
      index : int32;
      inFindIndex : int32;
      inTrainFlag : uint16;
      inTrainId : uint16)
    returns (outCondition : bool; outFindIndex : int32)
  var
    _L1 : int32;
    _L2 : bool;
    _L4 : int32;
    _L5 : int32;
    _L6 : bool;
  let
    _L1= #1 if _L2 then (_L5) else (_L4);
    _L2= inTrainFlag #1 <> 0 #3 and inTrainFlag #4 = inTrainId;
    _L4= inFindIndex;
    _L5= index;
    outCondition= _L6;
    outFindIndex= _L1;
    _L6= #1 not _L2;
  tel

  function #pragma kcg doc "Graphical_1" {Text = "列车信息有效并且未通信周期数小于等于10的车为通信车 列车信息无效或未通信周期数超过10的车为失联车"} #end
    #pragma kcg expand #end TrainIsLinking(
      inOCCycle : uint32;
      inTrainFlag : uint16;
      inTrainInfo_S : TrainInfo_Struct)
    returns (outResult : bool)
  var
    _L1 : uint32;
    _L3 : bool;
    _L4 : uint32;
    _L7 : bool;
    _L8 : bool;
  let
    _L1= inOCCycle #3 - inTrainInfo_S#7.Cycle;
    _L3= _L1 #1 <= _L4;
    _L4= LOSE_CONTACT_MAX_CYCLE;
    outResult= _L8;
    _L7= inTrainFlag #3 <> 0_ui16;
    _L8= _L7 #1 and _L3;
  tel

  function #pragma kcg expand #end FindInsertIndexByFlag_each(
      index : int32;
      inFindIndex : int32;
      inTrainFlag : uint16)
    returns (outCondition : bool; outFindIndex : int32)
  var
    _L1 : int32;
    _L2 : bool;
    _L4 : int32;
    _L5 : int32;
    _L6 : bool;
  let
    _L1= #1 if _L2 then (_L5) else (_L4);
    _L2= inTrainFlag #1 = 0;
    _L4= inFindIndex;
    _L5= index;
    outCondition= _L6;
    outFindIndex= _L1;
    _L6= #1 not _L2;
  tel

  function #pragma kcg doc "Graphical_1" {Text = "在列车表中查找可以插入的位置，如果找到返回存储的位置索引，否则返回-1"} #end
    #pragma kcg separate_io #end FindInsertIndexByFlag(
      inTrainFlag_A : uint16^TRAIN_MAX)
    returns (outFindIndex : int32)
  var
    _L1 : int32;
    _L3 : int32;
    _L4 : bool;
    _L5 : int32;
    _L8 : uint16^TRAIN_MAX;
  let
    _L3, _L1=
      (#2 foldwi #1 FindInsertIndexByFlag_each <<TRAIN_MAX>> if _L4)(_L5, _L8);
    _L4= true;
    _L5= - 1;
    _= _L3;
    outFindIndex= _L1;
    _L8= inTrainFlag_A;
  tel

  function #pragma kcg doc "Graphical_1" {Text = "功能：列车信息有效性及列车通信状态管理 列车信息有效性管理：         将发起中断连接申请的列车的信息置为无效，等待下次插入新的信息         列车有效性：0-列车信息无效，其它：列车ID 列车通信状态管理：         列车超过10周期未与OC通信认为列车失联，列车状态：true:通信，false:失联"} #end
    TrainInfoValidManage(
      inOCCycle : uint32;
      inTrainFlag_A : uint16^TRAIN_MAX;
      inTrainInfo_SA : TrainInfo_Struct^TRAIN_MAX)
    returns (
      outTrainFlag_A : uint16^TRAIN_MAX;
      outTrainCommState_A : bool^TRAIN_MAX)
  var
    _L2 : bool^TRAIN_MAX;
    _L1 : uint16^TRAIN_MAX;
    _L3 : uint32^TRAIN_MAX;
    _L4 : uint16^TRAIN_MAX;
    _L5 : TrainInfo_Struct^TRAIN_MAX;
  let
    _L1, _L2= (#1 map #1 TrainInfoValidManage_each <<TRAIN_MAX>>)(_L3, _L4, _L5);
    _L3= (inOCCycle)#1^TRAIN_MAX;
    _L4= inTrainFlag_A;
    _L5= inTrainInfo_SA;
    outTrainFlag_A= _L1;
    outTrainCommState_A= _L2;
  tel

  function #pragma kcg expand #end TrainInfoValidManage_each(
      inOCCycle : uint32;
      inTrainFlag : uint16;
      inTrainInfo_S : TrainInfo_Struct)
    returns (outTrainFlag : uint16; outTrainCommState : bool)
  var
    _L1 : uint16;
    _L3 : bool;
    _L5 : uint16;
    _L6 : uint16;
    _L9 : bool;
    _L10 : uint32;
    _L11 : TrainInfo_Struct;
  let
    _L1= #1 if _L3 then (_L5) else (_L6);
    _L3= inTrainFlag #1 <> 0 #1 and inTrainInfo_S#3.Contact_CT #2 = LINKBREAK_APPLY;
    outTrainFlag= _L1;
    _L5= 0_ui16;
    _L6= inTrainFlag;
    _L9= #1 TrainIsLinking(_L10, _L1, _L11);
    outTrainCommState= _L9;
    _L10= inOCCycle;
    _L11= inTrainInfo_S;
  tel

  function GetTrainDelAddInfo() returns ()
  let
  tel

  function GetTrainDelAddInfo_each() returns ()
  let
  tel

  function #pragma kcg doc "Graphical_1" {Text = "删除所有失联车"} #end
    #pragma kcg doc "Graphical_11" {Text = "添加失联车"} #end
    DATrainCmdProc_each(
      index : uint16;
      inTrainFlag_A : uint16^TRAIN_MAX;
      inTrainCommState_A : bool^TRAIN_MAX;
      inNumOfDATrainCmd : uint16;
      inDATrainCmd_S : DeleteAddTrain_CommandData_Struct)
    returns (
      outCondition : bool;
      outTrainFlag_A : uint16^TRAIN_MAX default = inTrainFlag_A;
      outTrainCommState_A : bool^TRAIN_MAX default = inTrainCommState_A)
  var
    _L12 : bool;
  let
    _L12= index #1 + 1 #1 < inNumOfDATrainCmd;
    outCondition= _L12;
    activate IfBlock1 if inDATrainCmd_S#3.DelOrAdd #2 = DEL_UCT
      then if inDATrainCmd_S#4.DeleteTrainOneorAll #3 = DELETE_TRAIN_ALL
      then var
        _L4 : bool^TRAIN_MAX;
        _L3 : uint16^TRAIN_MAX;
        _L5 : uint16^TRAIN_MAX;
        _L6 : bool^TRAIN_MAX;
      let
        _L3, _L4= (#1 map #1 DeleteAllLoseTrain_each <<TRAIN_MAX>>)(_L5, _L6);
        _L5= inTrainFlag_A;
        _L6= inTrainCommState_A;
        outTrainFlag_A= _L3;
        outTrainCommState_A= _L4;
      tel
      else if inDATrainCmd_S#5.DeleteTrainOneorAll #4 = DELETE_TRAIN_ONE
      then #pragma kcg doc "Graphical_1" {Text = "删除指定的失联车"} #end
      var
        _L2 : bool^TRAIN_MAX;
        _L1 : uint16^TRAIN_MAX;
        _L3 : uint16^TRAIN_MAX;
        _L4 : bool^TRAIN_MAX;
        _L5 : uint16^TRAIN_MAX;
      let
        _L1, _L2= (#2 map #1 DeleteSpecificLoseTrain_each <<TRAIN_MAX>>)(_L3, _L4, _L5);
        _L3= inTrainFlag_A;
        _L4= inTrainCommState_A;
        _L5= (inDATrainCmd_S#10.IVOCID)#1^TRAIN_MAX;
        outTrainFlag_A= _L1;
        outTrainCommState_A= _L2;
      tel
      else let
      tel
      else if inDATrainCmd_S#7.DelOrAdd #5 = ADD_UCT
      then var
        _L1 : bool^TRAIN_MAX;
        _L2 : uint16^TRAIN_MAX;
        _L3 : bool^TRAIN_MAX;
        _L4 : uint16^TRAIN_MAX;
      let
        _L1= (#3 map #1 AddSpecificLoseTrain_each <<TRAIN_MAX>>)(_L2, _L3, _L4);
        _L2= inTrainFlag_A;
        _L3= inTrainCommState_A;
        _L4= (inDATrainCmd_S#11.IVOCID)#2^TRAIN_MAX;
        outTrainCommState_A= _L1;
      tel
      else let
      tel
    returns ..;
  tel

  function #pragma kcg doc "Graphical_1" {Text = "功能：删除或增加非通信车命令处理 说明：该命令按照先到先执行的原则进行处理，删除命令的处理需要修改列车信           息的有效性，增加命令的处理需要修改列车的通信状态 "} #end
    DATrainCmdProc(
      inNumOfDATrainCmd : uint16;
      inDATrainCmd_SA : DeleteAddTrain_CommandData_Struct^CMD_MAX;
      inTrainFlag_A : uint16^TRAIN_MAX;
      inTrainCommState_A : bool^TRAIN_MAX)
    returns (
      outTrainFlag_A : uint16^TRAIN_MAX;
      outTrainCommState_A : bool^TRAIN_MAX)
  var
    _L4 : uint16;
    _L5 : bool;
    _L6 : uint16^CMD_MAX;
    _L7 : DeleteAddTrain_CommandData_Struct^CMD_MAX;
    _L11 : bool^TRAIN_MAX;
    _L10 : uint16^TRAIN_MAX;
    _L9 : bool;
    _L12 : uint16^TRAIN_MAX;
    _L13 : bool^TRAIN_MAX;
  let
    _L4, _L9, _L10, _L11=
      (#1 mapfoldwi 2 #1 DATrainCmdProc_each <<CMD_MAX>> if _L5 default ())(_L12,
        _L13, _L6, _L7);
    _L5= inNumOfDATrainCmd #1 > 0;
    _L6= (inNumOfDATrainCmd)#1^CMD_MAX;
    _L7= inDATrainCmd_SA;
    _L12= inTrainFlag_A;
    _L13= inTrainCommState_A;
    outTrainFlag_A= _L10;
    outTrainCommState_A= _L11;
    _= _L4;
    _= _L9;
  tel

  function TrainManage(
      inOCCycle : uint32;
      inNumOfDATrainCmd : uint16;
      inDATrainCmd_SA : DeleteAddTrain_CommandData_Struct^CMD_MAX;
      inTrainFlag_A : uint16^TRAIN_MAX;
      inTrainInfo_SA : TrainInfo_Struct^TRAIN_MAX)
    returns (
      outTrainFlag_A : uint16^TRAIN_MAX;
      outTrainCommState_A : bool^TRAIN_MAX)
  var
    _L2 : bool^TRAIN_MAX;
    _L1 : uint16^TRAIN_MAX;
    _L3 : uint32;
    _L4 : uint16^TRAIN_MAX;
    _L6 : TrainInfo_Struct^TRAIN_MAX;
    _L8 : bool^TRAIN_MAX;
    _L7 : uint16^TRAIN_MAX;
    _L9 : uint16;
    _L10 : DeleteAddTrain_CommandData_Struct^CMD_MAX;
  let
    _L1, _L2= #1 TrainInfoValidManage(_L3, _L4, _L6);
    _L3= inOCCycle;
    _L4= inTrainFlag_A;
    _L6= inTrainInfo_SA;
    _L7, _L8= #1 DATrainCmdProc(_L9, _L10, _L1, _L2);
    _L9= inNumOfDATrainCmd;
    _L10= inDATrainCmd_SA;
    outTrainFlag_A= _L7;
    outTrainCommState_A= _L8;
  tel

  function #pragma kcg expand #end DeleteAllLoseTrain_each(
      inTrainFlag : uint16;
      inTrainCommState : bool)
    returns (outTrainFlag : uint16; outTrainCommState : bool)
  var
    _L1 : uint16;
    _L2 : bool;
    _L3 : bool;
    _L4 : uint16;
    _L5 : bool;
    _L6 : uint16;
    _L7 : bool;
  let
    _L1, _L3= #1 if _L2 then (_L4, _L5) else (_L6, _L7);
    _L2= inTrainFlag #1 <> 0 #1 and #1 not inTrainCommState;
    outTrainFlag= _L1;
    outTrainCommState= _L3;
    _L4= 0_ui16;
    _L5= false;
    _L6= inTrainFlag;
    _L7= inTrainCommState;
  tel

  function #pragma kcg expand #end DeleteSpecificLoseTrain_each(
      inTrainFlag : uint16;
      inTrainCommState : bool;
      inSpecificTrainId : uint16)
    returns (outTrainFlag : uint16; outTrainCommState : bool)
  var
    _L1 : uint16;
    _L2 : bool;
    _L3 : bool;
    _L4 : uint16;
    _L5 : bool;
    _L6 : uint16;
    _L7 : bool;
  let
    _L1, _L3= #1 if _L2 then (_L4, _L5) else (_L6, _L7);
    _L2= inTrainFlag #1 = inSpecificTrainId #2 and #2 not inTrainCommState;
    outTrainFlag= _L1;
    outTrainCommState= _L3;
    _L4= 0_ui16;
    _L5= false;
    _L6= inTrainFlag;
    _L7= inTrainCommState;
  tel

  function #pragma kcg expand #end AddSpecificLoseTrain_each(
      inTrainFlag : uint16;
      inTrainCommState : bool;
      inSpecificTrainId : uint16)
    returns (outTrainCommState : bool)
  var
    _L1 : bool;
    _L2 : bool;
    _L5 : bool;
    _L7 : bool;
  let
    _L1= #1 if _L2 then (_L5) else (_L7);
    _L2= inTrainFlag #2 = inSpecificTrainId #2 and inTrainCommState;
    outTrainCommState= _L1;
    _L5= false;
    _L7= inTrainCommState;
  tel

  function #pragma kcg doc "Graphical_1" {Text = "VT车：列车信息有效、与OC处于通信状态"} #end
    #pragma kcg C:name TrainIsVT #end
    #pragma kcg separate_io #end TrainIsVT(
      inTrainInfoFlag : uint16;
      inTrainCommState : bool)
    returns (outResult : bool)
  var
    _L1 : bool;
    _L2 : bool;
    _L5 : bool;
  let
    _L1= inTrainInfoFlag #1 <> 0;
    _L2= inTrainCommState;
    _L5= _L1 #1 and _L2;
    outResult= _L5;
  tel

  function #pragma kcg doc "Graphical_1" {Text = "LCT车：列车信息有效、列车通信中断"} #end
    #pragma kcg C:name TrainIsLCT #end
    #pragma kcg separate_io #end TrainIsLCT(
      inTrainInfoFlag : uint16;
      inTrainCommState : bool)
    returns (outResult : bool)
  var
    _L1 : bool;
    _L5 : bool;
    _L9 : bool;
    _L12 : bool;
  let
    _L1= inTrainInfoFlag #1 <> 0;
    _L5= _L1 #1 and _L12;
    outResult= _L5;
    _L9= inTrainCommState;
    _L12= #1 not _L9;
  tel

end;


/* xscade source: E:/Work-TCT/6@VBTC_OC/0@SoftwareSource/OC_SCADE20190613/ScadeOCPeriodMain.xscade */
function ScadeOCPeriodMain(
    inATSLockDelCountDown_SA : ATSLockDelete_CountDown_Struct^CMD_MAX)
  returns (
    outRegionBlockFlag : uint16;
    outRegionBlockPosition_S : RegionBlockPosition_Struct;
    outTrainFlag_A : uint16^TRAIN_MAX;
    outTrainCommState_A : bool^TRAIN_MAX;
    outSignalInfo_SA : SignalInfo_Struct^SIGNAL_MAX;
    outElecPowerState : uint16;
    outSwitchFaultState_A : uint8^SWITCH_MAX;
    outSwitchInfo_SA : SwitchInfo_Struct^SWITCH_MAX;
    outSwitchLockType_A : uint8^SWITCH_MAX;
    outSwitchELock_SA : SwitchELock_Struct^SWITCH_MAX;
    outNumOfSwitchSLock_A : uint16^SWITCH_MAX;
    outSwitchSLockFlag_AA : bool^SLOCK_MAX^SWITCH_MAX;
    outSwitchSLock_SAA : SLock_Struct^SLOCK_MAX^SWITCH_MAX;
    outATSLockDelCountDown_SA : ATSLockDelete_CountDown_Struct^CMD_MAX;
    outMultSwitch_SA : MultSwitch_Struct^MULTSWITCH_MAX;
    outNumOfHoldTrainCmdData : uint16;
    outHoldTrainCmdDataFlag_A : bool^CMD_MAX;
    outHoldTrainCmdData_SA : HoldTrain_CommandData_Struct^CMD_MAX;
    outNumOfJumpTrainCmdData : uint16;
    outJumpTrainCmdDataFlag_A : bool^CMD_MAX;
    outJumpTrainCmdData_SA : JumpTrain_CommandData_Send_Struct^CMD_MAX;
    outTsrValidFlag : uint8;
    outNumOfTsrData : uint16;
    outTsrData_SA : TSR_Struct^TSR_MAX;
    outPhySecBlockIdFlag_A : uint8^PHYSEC_MAX;
    outPhySecBlockId_A : uint16^PHYSEC_MAX)
var
  tmpCmdATSLockFlag_A : bool^CMD_MAX;
  tmpCmdVOBCLockFlag_A : bool^CMD_MAX;
  tmpCmdTMCLockFlag_A : bool^CMD_MAX;
  tmpCmdHCOCLockFlag_A : bool^CMD_MAX;
  tmpCmdSwitchFlag_A : bool^CMD_MAX;
  tmpRegionBlockFlag : uint16;
  tmpSwitchLockType_A : uint8^SWITCH_MAX;
  tmpSwitchELock_SA : SwitchELock_Struct^SWITCH_MAX;
  tmpNumOfSwitchSLock_A : uint16^SWITCH_MAX;
  tmpSwitchSLockFlag_AA : bool^SLOCK_MAX^SWITCH_MAX;
  tmpRegionBlockPosition : RegionBlockPosition_Struct;
  tmpPhySecBlockIdFlag_A : uint8^PHYSEC_MAX;
  _L10 : bool^CMD_MAX;
  _L9 : bool^CMD_MAX;
  _L8 : bool^CMD_MAX;
  _L7 : bool^CMD_MAX;
  _L6 : bool^CMD_MAX;
  _L5 : uint16;
  _L4 : uint16;
  _L3 : uint16;
  _L2 : uint16;
  _L1 : uint16;
  _L18 : ATSLockDelete_CountDown_Struct^CMD_MAX;
  _L28 : uint16;
  _L50 : uint16;
  _L51 : uint16;
  _L52 : uint16;
  _L53 : uint16;
  _L54 : uint16;
  _L56 : ATSLock_CommandData_Struct^CMD_MAX;
  _L57 : VOBCLock_CommandData_Struct^CMD_MAX;
  _L58 : VOBCLock_CommandData_Struct^CMD_MAX;
  _L59 : ATSLock_CommandData_Struct^CMD_MAX;
  _L60 : Switch_CommandData_Struct^CMD_MAX;
  _L63 : uint16;
  _L64 : SwitchState_Struct^SWITCH_MAX;
  _L65 : uint8^SWITCH_MAX;
  _L77 : SLock_Struct^SLOCK_MAX^SWITCH_MAX;
  _L76 : bool^SLOCK_MAX^SWITCH_MAX;
  _L75 : uint16^SWITCH_MAX;
  _L74 : SwitchELock_Struct^SWITCH_MAX;
  _L73 : uint8^SWITCH_MAX;
  _L72 : SwitchInfo_Struct^SWITCH_MAX;
  _L71 : uint8^SWITCH_MAX;
  _L78 : uint32;
  _L79 : uint16;
  _L80 : SwitchState_Struct^SWITCH_MAX;
  _L82 : SwitchInfo_Struct^SWITCH_MAX;
  _L81 : uint8^SWITCH_MAX;
  _L85 : SwitchELock_Struct^SWITCH_MAX;
  _L84 : uint16^SWITCH_MAX;
  _L83 : bool^SLOCK_MAX^SWITCH_MAX;
  _L86 : SLock_Struct^SLOCK_MAX^SWITCH_MAX;
  _L87 : uint16;
  _L88 : Switch_Reset_CommandData_Struct^CMD_MAX;
  _L89 : bool^CMD_MAX;
  _L90 : bool^CMD_MAX;
  _L91 : bool^CMD_MAX;
  _L92 : bool^CMD_MAX;
  _L93 : bool^CMD_MAX;
  _L94 : uint16;
  _L95 : ATSLockDelete_CommandData_Struct^CMD_MAX;
  _L100 : VOBCLock_CommandData_Struct^CMD_MAX;
  _L99 : Switch_CommandData_Struct^CMD_MAX;
  _L98 : ATSLock_CommandData_Struct^CMD_MAX;
  _L97 : ATSLock_CommandData_Struct^CMD_MAX;
  _L96 : VOBCLock_CommandData_Struct^CMD_MAX;
  _L109 : bool^TRAIN_MAX;
  _L108 : uint16^TRAIN_MAX;
  _L110 : uint32;
  _L111 : uint16;
  _L112 : DeleteAddTrain_CommandData_Struct^CMD_MAX;
  _L113 : uint16^TRAIN_MAX;
  _L114 : TrainInfo_Struct^TRAIN_MAX;
  _L115 : SignalInfo_Struct^SIGNAL_MAX;
  _L125 : uint16;
  _L126 : Signal_SendCommandData_Struct^CMD_MAX;
  _L127 : uint16;
  _L128 : SignalState_Struct^SIGNAL_MAX;
  _L129 : SignalInfo_Struct^SIGNAL_MAX;
  _L130 : uint16^TRAIN_MAX;
  _L131 : bool^TRAIN_MAX;
  _L132 : uint16;
  _L133 : Region_Block_CommandData_Struct^CMD_MAX;
  _L137 : SwitchELock_Struct^SWITCH_MAX;
  _L136 : uint8^SWITCH_MAX;
  _L135 : uint16;
  _L134 : uint16;
  _L139 : uint16;
  _L140 : PowerLockCommandData_Struct;
  _L141 : bool^SLOCK_MAX^SWITCH_MAX;
  _L142 : uint16^SWITCH_MAX;
  _L151 : uint16^SWITCH_MAX;
  _L152 : SwitchELock_Struct^SWITCH_MAX;
  _L153 : uint8^SWITCH_MAX;
  _L154 : bool^SLOCK_MAX^SWITCH_MAX;
  _L155 : uint16;
  _L156 : ATSLockDelete_CountDown_Struct^CMD_MAX;
  _L157 : ATSLockDelete_CountDown_Struct^CMD_MAX;
  _L158 : MultSwitch_Struct^MULTSWITCH_MAX;
  _L159 : MultSwitch_Struct^MULTSWITCH_MAX;
  _L160 : uint16;
  _L161 : uint16;
  _L162 : MultSwitch_CommandData_Struct^CMD_MAX;
  _L163 : MultSwitch_Struct^MULTSWITCH_MAX;
  _L168 : uint16;
  _L167 : uint16;
  _L166 : MultSwitch_CommandData_Struct^CMD_MAX;
  _L169 : uint16;
  _L170 : uint8;
  _L171 : uint8;
  _L174 : HoldTrain_CommandData_Struct^CMD_MAX;
  _L173 : bool^CMD_MAX;
  _L172 : uint16;
  _L175 : uint16;
  _L176 : HoldTrain_CommandData_Struct^CMD_MAX;
  _L177 : uint16;
  _L178 : HoldTrain_CommandData_Struct^CMD_MAX;
  _L179 : bool^CMD_MAX;
  _L182 : JumpTrain_CommandData_Send_Struct^CMD_MAX;
  _L181 : bool^CMD_MAX;
  _L180 : uint16;
  _L183 : uint16;
  _L184 : JumpTrain_CommandData_Struct^CMD_MAX;
  _L185 : uint16;
  _L186 : bool^CMD_MAX;
  _L187 : JumpTrain_CommandData_Send_Struct^CMD_MAX;
  _L190 : TSR_Struct^TSR_MAX;
  _L189 : uint16;
  _L188 : uint8;
  _L191 : uint16;
  _L192 : TSR_CTRL_CommandData_Struct^CMD_MAX;
  _L193 : uint8;
  _L194 : uint16;
  _L195 : TSR_Struct^TSR_MAX;
  _L196 : RegionBlockPosition_Struct;
  _L198 : RegionBlockPosition_Struct;
  _L199 : RegionBlockPosition_Struct;
  _L200 : RegionBlockPosition_Struct;
  _L201 : uint16;
  _L203 : uint16^PHYSEC_MAX;
  _L202 : uint8^PHYSEC_MAX;
  _L204 : uint16;
  _L205 : PhySec_Block_CommandData_Struct^CMD_MAX;
  _L206 : uint16^PHYSEC_MAX;
  _L207 : uint8^PHYSEC_MAX;
  _L209 : uint8^PHYSEC_MAX;
  _L210 : uint8^PHYSEC_MAX;
let
  _L1, _L6, _L4, _L9, _L2, _L7, _L3, _L8, _L5, _L10=
    #1 Lock_SwitchCommandInvalidManage::CmdValidityManage(_L54, _L56, _L53,
      _L57, _L52, _L58, _L51, _L59, _L50, _L60, _L18, _L63, _L64, _L65);
  _L18= inATSLockDelCountDown_SA;
  _L28, _L196=
    #2 RegionBlockManage::RegionBlockManage(_L132, _L133, _L169, _L198, _L170);
  _= _L1;
  _= _L2;
  _= _L3;
  _= _L5;
  _= _L4;
  _L50= g_stOCRevCmdDataStru#1.CommandNum_Switch;
  _L51= g_stOCRevCmdDataStru#3.CommandNum_HCOCLock;
  _L52= g_stOCRevCmdDataStru#5.CommandNum_TMCLock;
  _L53= g_stOCRevCmdDataStru#7.CommandNum_VOBCLock;
  _L54= g_stOCRevCmdDataStru#9.CommandNum_ATSLock;
  _L56= g_stOCRevCmdDataStru#13.OCRevATSLockCmdDataArray;
  _L57= g_stOCRevCmdDataStru#15.OCRevVOBCLockCmdDataArray;
  _L58= g_stOCRevCmdDataStru#17.OCRevTMCLockCmdDataArray;
  _L59= g_stOCRevCmdDataStru#19.OCRevHCOCLockCmdDataArray;
  _L60= g_stOCRevCmdDataStru#21.OCRevSwitchCmdDataArray;
  _L63= g_stOC#25.SwitchNum;
  _L64= g_stOC#26.SwitchStateArray;
  _L65= g_stOC#27.SwitchFaultStateArray;
  tmpCmdATSLockFlag_A= _L6;
  tmpCmdHCOCLockFlag_A= _L9;
  tmpCmdSwitchFlag_A= _L10;
  tmpCmdTMCLockFlag_A= _L8;
  tmpCmdVOBCLockFlag_A= _L7;
  _L71, _L72, _L73, _L74, _L75, _L76, _L77, _L156=
    #2 SwitchManage::SwitchManage(_L78, _L79, _L80, _L82, _L81, _L85, _L84,
      _L83, _L86, _L87, _L88, _L89, _L98, _L93, _L96, _L90, _L97, _L92, _L100,
      _L91, _L99, _L94, _L95, _L157);
  _L78= g_dwOCCycle;
  _L79= g_stOC#28.SwitchNum;
  _L80= g_stOC#35.SwitchStateArray;
  _L81= g_stOC#37.SwitchLockTypeArray;
  _L82= g_stOC#36.SwitchInfoArray;
  _L83= g_stOC#41.SwitchSLockFlagArray;
  _L84= g_stOC#39.SwitchSLockNumArray;
  _L85= g_stOC#38.SwitchELockArray;
  _L86= g_stOC#42.SwitchSLockArray;
  _L87= g_stOCRevCmdDataStru#44.CommandNum_SwitchReset;
  _L88= g_stOCRevCmdDataStru#46.OCRevATSSwitchResetCmdDataArray;
  _L89= tmpCmdATSLockFlag_A;
  _L90= tmpCmdHCOCLockFlag_A;
  _L91= tmpCmdSwitchFlag_A;
  _L92= tmpCmdTMCLockFlag_A;
  _L93= tmpCmdVOBCLockFlag_A;
  _L94= g_stOCRevCmdDataStru#48.CommandNum_ATSLockDelete;
  _L95= g_stOCRevCmdDataStru#50.OCRevATSLockDeleteCmdDataArray;
  _L96= g_stOCRevCmdDataStru#55.OCRevVOBCLockCmdDataArray;
  _L97= g_stOCRevCmdDataStru#54.OCRevHCOCLockCmdDataArray;
  _L98= g_stOCRevCmdDataStru#53.OCRevATSLockCmdDataArray;
  _L99= g_stOCRevCmdDataStru#52.OCRevSwitchCmdDataArray;
  _L100= g_stOCRevCmdDataStru#51.OCRevTMCLockCmdDataArray;
  _L108, _L109= #2 TrainManage::TrainManage(_L110, _L111, _L112, _L113, _L114);
  _L110= g_dwOCCycle;
  _L111= g_stOCRevCmdDataStru#56.CommandNum_DeleteAddTrain;
  _L112= g_stOCRevCmdDataStru#58.OCRevDeleteAddTrainCmdDataArray;
  _L113= g_stOC#60.TrainInfoFlagArray;
  _L114= g_stOC#62.TrainInfoArray;
  outTrainFlag_A= _L108;
  outTrainCommState_A= _L109;
  _L115=
    #1 SignalCtrl::SignalCtrl(_L171, _L125, _L126, _L127, _L128, _L129, _L130,
      _L131);
  _L125= g_stOCRevCmdDataStru#71.CommandNum_SignalCtrl;
  _L126= g_stOCRevCmdDataStru#73.OCRevSignalCtrlCmdDataArray;
  _L127= g_stOC#75.SignalNum;
  _L128= g_stOC#77.SignalStateArray;
  _L129= g_stOC#79.SignalInfoArray;
  _L130= outTrainFlag_A;
  _L131= outTrainCommState_A;
  outSignalInfo_SA= _L115;
  _L132= g_stOCRevCmdDataStru#81.CommandNum_RegionBlock;
  _L133= g_stOCRevCmdDataStru#83.OCRevRegionBlockCmdDataArray;
  _L134, _L199, _L135, _L136, _L137, _L142, _L141, _L210=
    #2 PowerLockDeleteManage::PowerLockDelManage(_L139, _L201, _L200, _L140,
      _L155, _L153, _L152, _L151, _L154, _L209);
  outRegionBlockFlag= _L134;
  tmpRegionBlockFlag= _L28;
  _L139= tmpRegionBlockFlag;
  _L140= g_stOCRevCmdDataStru#85.OCRevPowerLockCmdDataArray;
  outElecPowerState= _L135;
  outSwitchLockType_A= _L136;
  outSwitchELock_SA= _L137;
  outNumOfSwitchSLock_A= _L142;
  outSwitchSLockFlag_AA= _L141;
  outSwitchFaultState_A= _L71;
  outSwitchInfo_SA= _L72;
  outSwitchSLock_SAA= _L77;
  tmpSwitchLockType_A= _L73;
  tmpSwitchELock_SA= _L74;
  tmpNumOfSwitchSLock_A= _L75;
  tmpSwitchSLockFlag_AA= _L76;
  _L151= tmpNumOfSwitchSLock_A;
  _L152= tmpSwitchELock_SA;
  _L153= tmpSwitchLockType_A;
  _L154= tmpSwitchSLockFlag_AA;
  _L155= g_stOC#86.SwitchNum;
  _L157= inATSLockDelCountDown_SA;
  outATSLockDelCountDown_SA= _L156;
  _L158= #1 MultSwitchManage::AddLock_MultSwitch(_L160, _L161, _L162, _L163);
  _L159= #1 MultSwitchManage::DeleteLock_MultSwitch(_L168, _L167, _L166, _L158);
  _L160= g_stOCRevCmdDataStru#87.CommandNum_MultSwitch;
  _L161= g_stOC#88.MultSwitchNum;
  _L162= g_stOCRevCmdDataStru#89.OCRevMultSwitchCmdDataArray;
  _L163= g_stOC#90.MultSwitchStateArray;
  _L166= g_stOCRevCmdDataStru#95.OCRevMultSwitchCmdDataArray;
  _L167= g_stOC#94.MultSwitchNum;
  _L168= g_stOCRevCmdDataStru#93.CommandNum_MultSwitch;
  outMultSwitch_SA= _L159;
  _L169= g_stOC#96.RegionBlockFlag;
  _L170= g_stOC#97.WSLoseInputFlag;
  _L171= g_stOC#98.TMCLoseInputFlag;
  _L172, _L173, _L174=
    #1 HoldTrainManage::HoldTrainManage(_L177, _L179, _L178, _L175, _L176);
  _L175= g_stOCRevCmdDataStru#99.CommandNum_HoldTrain;
  _L176= g_stOCRevCmdDataStru#101.OCRevHoldTrainCmdDataArray;
  _L177= g_stOC#102.HoldTrainNum;
  _L178= g_stOC#104.HoldTrainCmdDataArray;
  _L179= g_stOC#106.HoldTrainCmdDataFlagArray;
  outNumOfHoldTrainCmdData= _L172;
  outHoldTrainCmdDataFlag_A= _L173;
  outHoldTrainCmdData_SA= _L174;
  _L180, _L181, _L182=
    #1 JumpTrainManage::JumpTrainManage(_L185, _L186, _L187, _L183, _L184);
  _L183= g_stOCRevCmdDataStru#107.CommandNum_JumpTrain;
  _L184= g_stOCRevCmdDataStru#109.OCRevJumpTrainCmdDataArray;
  _L185= g_stOC#111.JumpTrainNum;
  _L186= g_stOC#113.JumpTrainCmdDataFlagArray;
  _L187= g_stOC#115.JumpTrainCmdDataArray;
  outNumOfJumpTrainCmdData= _L180;
  outJumpTrainCmdDataFlag_A= _L181;
  outJumpTrainCmdData_SA= _L182;
  _L188, _L189, _L190= #1 TSRManage::TSRManage(_L193, _L191, _L192, _L194, _L195);
  _L191= g_stOCRevCmdDataStru#116.CommandNum_TSRCtrl;
  _L192= g_stOCRevCmdDataStru#118.OCRevTSRCtrlCmdDataArray;
  _L193= g_stOC#120.TMCInputFlag;
  _L194= g_stOC#122.TSRNum;
  _L195= g_stOC#124.TSRDataArray;
  outTsrValidFlag= _L188;
  outNumOfTsrData= _L189;
  outTsrData_SA= _L190;
  _L198= g_stOC#126.RegionBlockPositionStruct;
  tmpRegionBlockPosition= _L196;
  _L200= tmpRegionBlockPosition;
  outRegionBlockPosition_S= _L199;
  _L201= g_stOC#127.ElecPowerFlag;
  _L202, _L203=
    #1 PhySecBlockManage::PhySecBlockManage(_L207, _L206, _L204, _L205);
  _L204= g_stOCRevCmdDataStru#128.CommandNum_PhySecBlock;
  _L205= g_stOCRevCmdDataStru#129.OCRevPhySecBlockCmdDataArray;
  _L206= g_stOC#130.PhySecBlockIdArray;
  _L207= g_stOC#131.PhySecBlockIdFlagArray;
  tmpPhySecBlockIdFlag_A= _L202;
  _L209= tmpPhySecBlockIdFlag_A;
  outPhySecBlockIdFlag_A= _L210;
  outPhySecBlockId_A= _L203;
tel


/* xscade source: E:/Work-TCT/6@VBTC_OC/0@SoftwareSource/OC_SCADE20190613/SwitchManage.xscade */
package SwitchManage
  package DeleteLockManage
    function #pragma kcg expand #end
      #pragma kcg separate_io #end IsDelSLockInfoByCmd(
        inNumOfDelSLock : uint16;
        inDelSLock : bool;
        inATSCmd_S : ATSLock_CommandData_Struct;
        inVOBCCmd_S : VOBCLock_CommandData_Struct;
        inHCOCCmd_S : ATSLock_CommandData_Struct;
        inTMCCmd_S : VOBCLock_CommandData_Struct;
        inNeedDelATSSLock : bool;
        inNeedDelHCOCSLock : bool;
        inNeedDelTMCSLock : bool;
        inNeedDelVOBCSLock : bool;
        inSLockFlag : bool;
        inSLock_S : SLock_Struct)
      returns (outNumOfDelSLock : uint16; outDelSLock : bool)
    var
      ATSDelSLock : bool;
      VOBCDelSLock : bool;
      HCOCDelSLock : bool;
      TMCDelSLock : bool;
      _L3 : bool;
      _L4 : bool;
      _L5 : bool;
      _L6 : bool;
      _L7 : uint16;
      _L8 : uint16;
      _L13 : uint16;
    let
      _L3, _L7= #1 if _L4 then (_L5, _L13) else (_L6, _L8);
      _L4= ATSDelSLock #1 or HCOCDelSLock #1 or VOBCDelSLock #1 or TMCDelSLock;
      _L5= true;
      _L6= inDelSLock;
      outDelSLock= _L3;
      outNumOfDelSLock= _L7;
      _L8= inNumOfDelSLock;
      _L13= inNumOfDelSLock #1 + 1;
      ATSDelSLock=
        inSLockFlag #21 and inNeedDelATSSLock #21 and
        inATSCmd_S#69.SourceID #35 = inSLock_S#70.SLockId;
      VOBCDelSLock=
        inSLockFlag #22 and inNeedDelVOBCSLock #22 and
        inVOBCCmd_S#71.SourceID #36 = inSLock_S#72.SLockId;
      HCOCDelSLock=
        inSLockFlag #23 and inNeedDelHCOCSLock #23 and
        inHCOCCmd_S#73.SourceID #37 = inSLock_S#74.SLockId;
      TMCDelSLock=
        inSLockFlag #24 and inNeedDelTMCSLock #24 and
        inTMCCmd_S#75.SourceID #38 = inSLock_S#76.SLockId;
    tel

    function #pragma kcg expand #end
      #pragma kcg separate_io #end GetDelInfoByCmd(
        inDelELock : bool;
        inDelSLock_A : bool^SLOCK_MAX;
        inNumOfDelSLock : uint16;
        inATSCmdFlag : bool;
        inVOBCCmdFlag : bool;
        inHCOCCmdFlag : bool;
        inTMCCmdFlag : bool;
        inATSCmd_S : ATSLock_CommandData_Struct;
        inVOBCCmd_S : VOBCLock_CommandData_Struct;
        inHCOCCmd_S : ATSLock_CommandData_Struct;
        inTMCCmd_S : VOBCLock_CommandData_Struct;
        inSwitchId : uint16;
        inSwitchMoveState : uint8;
        inSwitchELockId : uint16;
        inSwitchSLockFlag_A : bool^SLOCK_MAX;
        inSwitchSLock_SA : SLock_Struct^SLOCK_MAX)
      returns (
        outDelELock : bool;
        outDelSLock_A : bool^SLOCK_MAX;
        outNumOfDelSLock : uint16)
    var
      NeedDelATSELock : bool;
      NeedDelATSSLock : bool;
      NeedDelVOBCELock : bool;
      NeedDelHCOCELock : bool;
      NeedDelTMCELock : bool;
      NeedDelVOBCSLock : bool;
      NeedDelTMCSLock : bool;
      NeedDelHCOCSLock : bool;
      _L13 : bool;
      _L14 : bool;
      _L15 : bool;
      _L16 : bool;
      _L18 : bool^SLOCK_MAX;
      _L17 : uint16;
      _L21 : ATSLock_CommandData_Struct^SLOCK_MAX;
      _L22 : VOBCLock_CommandData_Struct^SLOCK_MAX;
      _L24 : VOBCLock_CommandData_Struct^SLOCK_MAX;
      _L23 : ATSLock_CommandData_Struct^SLOCK_MAX;
      _L27 : bool^SLOCK_MAX;
      _L26 : bool^SLOCK_MAX;
      _L25 : bool^SLOCK_MAX;
      _L28 : bool^SLOCK_MAX;
      _L29 : bool^SLOCK_MAX;
      _L30 : SLock_Struct^SLOCK_MAX;
      _L31 : bool^SLOCK_MAX;
      _L32 : uint16;
    let
      _L13= #1 if _L14 then (_L15) else (_L16);
      _L14=
        NeedDelATSELock #1 or NeedDelHCOCELock #1 or NeedDelTMCELock #1 or
        NeedDelVOBCELock;
      _L15= true;
      _L16= inDelELock;
      outDelELock= _L13;
      _L17, _L18=
        (#2 mapfold 1 #1 IsDelSLockInfoByCmd <<SLOCK_MAX>>)(_L32, _L31, _L21,
          _L22, _L23, _L24, _L27, _L25, _L26, _L28, _L29, _L30);
      _L21= (inATSCmd_S)#1^SLOCK_MAX;
      _L22= (inVOBCCmd_S)#2^SLOCK_MAX;
      _L23= (inHCOCCmd_S)#3^SLOCK_MAX;
      _L24= (inTMCCmd_S)#4^SLOCK_MAX;
      _L25= (NeedDelHCOCSLock)#5^SLOCK_MAX;
      _L26= (NeedDelTMCSLock)#6^SLOCK_MAX;
      _L27= (NeedDelATSSLock)#7^SLOCK_MAX;
      _L28= (NeedDelVOBCSLock)#8^SLOCK_MAX;
      _L29= inSwitchSLockFlag_A;
      _L30= inSwitchSLock_SA;
      outNumOfDelSLock= _L17;
      outDelSLock_A= _L18;
      _L31= inDelSLock_A;
      _L32= inNumOfDelSLock;
      NeedDelATSELock=
        inATSCmdFlag #25 and inATSCmd_S#82.LockAdd_Delete #82 = DEL_LOCK #25 and
        inATSCmd_S#83.SwitchID #83 = inSwitchId #25 and
        inSwitchMoveState #25 <> FLAG_SET #25 and
        inATSCmd_S#84.ELcok_SLock #84 = LOCK_E #25 and
        inATSCmd_S#85.SourceID #85 = inSwitchELockId;
      NeedDelVOBCELock=
        inVOBCCmdFlag #26 and inVOBCCmd_S#86.LockAdd_Delete #86 = DEL_LOCK #26
        and
        inVOBCCmd_S#87.SwitchID #87 = inSwitchId #26 and
        inSwitchMoveState #26 <> FLAG_SET #26 and
        inVOBCCmd_S#88.SourceID #88 = inSwitchELockId;
      NeedDelHCOCELock=
        inHCOCCmdFlag #27 and inHCOCCmd_S#89.LockAdd_Delete #89 = DEL_LOCK #27
        and
        inHCOCCmd_S#90.SwitchID #90 = inSwitchId #27 and
        inSwitchMoveState #27 <> FLAG_SET #27 and
        inHCOCCmd_S#91.ELcok_SLock #91 = LOCK_E #27 and
        inHCOCCmd_S#92.SourceID #92 = inSwitchELockId;
      NeedDelTMCELock=
        inTMCCmdFlag #28 and inTMCCmd_S#93.LockAdd_Delete #93 = DEL_LOCK #28 and
        inTMCCmd_S#94.SwitchID #94 = inSwitchId #28 and
        inSwitchMoveState #28 <> FLAG_SET #28 and
        inTMCCmd_S#95.SourceID #95 = inSwitchELockId;
      NeedDelATSSLock=
        inATSCmdFlag #29 and inATSCmd_S#96.LockAdd_Delete #96 = DEL_LOCK #29 and
        inATSCmd_S#97.SwitchID #97 = inSwitchId #29 and
        inSwitchMoveState #29 <> FLAG_SET #29 and
        inATSCmd_S#98.ELcok_SLock #98 = LOCK_S;
      NeedDelVOBCSLock=
        inVOBCCmdFlag #30 and inVOBCCmd_S#99.LockAdd_Delete #99 = DEL_LOCK #30
        and
        inVOBCCmd_S#100.SwitchID #100 = inSwitchId #30 and
        inSwitchMoveState #30 <> FLAG_SET;
      NeedDelHCOCSLock=
        inHCOCCmdFlag #31 and inHCOCCmd_S#101.LockAdd_Delete #101 = DEL_LOCK #31
        and
        inHCOCCmd_S#102.SwitchID #102 = inSwitchId #31 and
        inSwitchMoveState #31 <> FLAG_SET #31 and
        inHCOCCmd_S#103.ELcok_SLock #103 = LOCK_S;
      NeedDelTMCSLock=
        inTMCCmdFlag #32 and inTMCCmd_S#104.LockAdd_Delete #104 = DEL_LOCK #32
        and
        inTMCCmd_S#105.SwitchID #105 = inSwitchId #32 and
        inSwitchMoveState #32 <> FLAG_SET;
    tel

    function #pragma kcg expand #end DelLockManage_each(
        inATSCmdFlag_A : bool^CMD_MAX;
        inVOBCCmdFlag_A : bool^CMD_MAX;
        inHCOCCmdFlag_A : bool^CMD_MAX;
        inTMCCmdFlag_A : bool^CMD_MAX;
        inATSCmd_SA : ATSLock_CommandData_Struct^CMD_MAX;
        inVOBCCmd_SA : VOBCLock_CommandData_Struct^CMD_MAX;
        inHCOCCmd_SA : ATSLock_CommandData_Struct^CMD_MAX;
        inTMCCmd_SA : VOBCLock_CommandData_Struct^CMD_MAX;
        inSwitchState_S : SwitchState_Struct;
        inSwitchInfo_S : SwitchInfo_Struct;
        inSwitchLockType : uint8;
        inSwitchELock_S : SwitchELock_Struct;
        inNumOfSwitchSLock : uint16;
        inSwitchSLockFlag_A : bool^SLOCK_MAX;
        inSwitchSLock_SA : SLock_Struct^SLOCK_MAX)
      returns (
        outSwitchLockType : uint8 default = inSwitchLockType;
        outSwitchELock_S : SwitchELock_Struct default = inSwitchELock_S;
        outNumOfSwitchSLock : uint16 default = inNumOfSwitchSLock;
        outSwitchSLockFlag_A : bool^SLOCK_MAX default = inSwitchSLockFlag_A)
    var
      NeedDelELock : bool;
      NeedDelSLock_A : bool^SLOCK_MAX;
      NumOfDelSLock : uint16;
      _L3 : uint16;
      _L2 : bool^SLOCK_MAX;
      _L1 : bool;
      _L4 : bool;
      _L5 : bool^SLOCK_MAX;
      _L6 : uint16;
      _L7 : bool^CMD_MAX;
      _L8 : bool^CMD_MAX;
      _L9 : bool^CMD_MAX;
      _L10 : bool^CMD_MAX;
      _L11 : ATSLock_CommandData_Struct^CMD_MAX;
      _L12 : VOBCLock_CommandData_Struct^CMD_MAX;
      _L13 : ATSLock_CommandData_Struct^CMD_MAX;
      _L14 : VOBCLock_CommandData_Struct^CMD_MAX;
      _L15 : uint16^CMD_MAX;
      _L16 : uint8^CMD_MAX;
      _L17 : uint16^CMD_MAX;
      _L18 : bool^SLOCK_MAX^CMD_MAX;
      _L19 : SLock_Struct^SLOCK_MAX^CMD_MAX;
    let
      _L1, _L2, _L3=
        (#2 mapfold 3 #1 GetDelInfoByCmd <<CMD_MAX>>)(_L4, _L5, _L6, _L7, _L8,
          _L9, _L10, _L11, _L12, _L13, _L14, _L15, _L16, _L17, _L18, _L19);
      _L4= false;
      _L5= (false)#1^SLOCK_MAX;
      _L6= 0_ui16;
      _L7= inATSCmdFlag_A;
      _L8= inVOBCCmdFlag_A;
      _L9= inHCOCCmdFlag_A;
      _L10= inTMCCmdFlag_A;
      _L11= inATSCmd_SA;
      _L12= inVOBCCmd_SA;
      _L13= inHCOCCmd_SA;
      _L14= inTMCCmd_SA;
      _L15= (inSwitchState_S#1.Id)#2^CMD_MAX;
      _L16= (inSwitchInfo_S#2.MoveState)#3^CMD_MAX;
      _L17= (inSwitchELock_S#3.ELockId)#4^CMD_MAX;
      _L18= (inSwitchSLockFlag_A)#5^CMD_MAX;
      _L19= (inSwitchSLock_SA)#6^CMD_MAX;
      NeedDelELock= _L1;
      NeedDelSLock_A= _L2;
      NumOfDelSLock= _L3;
      activate IfBlock1 if inSwitchLockType #1 = LOCK_E #1 and NeedDelELock
        then let
          outSwitchELock_S= (#1 make SwitchELock_Struct)(0, 0, 0);
          outSwitchLockType= 0;
        tel
        else if inSwitchLockType #4 = LOCK_S #2 and NumOfDelSLock #1 > 0
        then var
          _L2 : uint16;
          _L1 : bool^SLOCK_MAX;
          _L4 : uint16;
          _L5 : bool^SLOCK_MAX;
          _L6 : uint8;
          _L8 : uint8;
          _L9 : uint8;
          _L10 : bool^SLOCK_MAX;
          _L11 : uint16;
          _L12 : bool;
        let
          _L1, _L2= #1 DeleteSwitchSLock(_L10, _L11, _L4, _L5);
          _L4= inNumOfSwitchSLock;
          _L5= inSwitchSLockFlag_A;
          outNumOfSwitchSLock= _L2;
          outSwitchSLockFlag_A= _L1;
          _L6= #1 if _L12 then (_L8) else (_L9);
          _L8= 0_ui8;
          outSwitchLockType= _L6;
          _L9= inSwitchLockType;
          _L10= NeedDelSLock_A;
          _L11= NumOfDelSLock;
          _L12= outNumOfSwitchSLock #5 = 0_ui16;
        tel
        else let
        tel
      returns ..;
    tel

    function #pragma kcg expand #end
      #pragma kcg separate_io #end DeleteSwitchSLock_each(
        inNeedDel : bool;
        inSwitchSLockFlag : bool)
      returns (outSwitchSLockFlag : bool)
    var
      _L1 : bool;
      _L2 : bool;
      _L3 : bool;
      _L4 : bool;
    let
      _L1= #1 if _L2 then (_L3) else (_L4);
      _L2= inNeedDel;
      _L3= false;
      _L4= inSwitchSLockFlag;
      outSwitchSLockFlag= _L1;
    tel

    function #pragma kcg expand #end DeleteSwitchSLock(
        inNeedDel_A : bool^SLOCK_MAX;
        inNumOfDelSLock : uint16;
        inNumOfSwitchSLock : uint16;
        inSwitchSLockFlag_A : bool^SLOCK_MAX)
      returns (
        outSwitchSLockFlag_A : bool^SLOCK_MAX default = inSwitchSLockFlag_A;
        outNumOfSwitchSLock : uint16 default = inNumOfSwitchSLock)
    var
      _L2 : bool^SLOCK_MAX;
      _L4 : bool^SLOCK_MAX;
      _L5 : bool^SLOCK_MAX;
      _L7 : uint16;
      _L8 : bool;
      _L9 : uint16;
      _L10 : uint16;
    let
      _L2= (#2 map #1 DeleteSwitchSLock_each <<SLOCK_MAX>>)(_L4, _L5);
      _L4= inNeedDel_A;
      _L5= inSwitchSLockFlag_A;
      outSwitchSLockFlag_A= _L2;
      _L7= #1 if _L8 then (_L9) else (_L10);
      _L8= inNumOfSwitchSLock #1 >= inNumOfDelSLock;
      outNumOfSwitchSLock= _L7;
      _L9= inNumOfSwitchSLock #1 - inNumOfDelSLock;
      _L10= 0_ui16;
    tel

  end;

  package AddLockManage
    function #pragma kcg doc "Graphical_1" {Text = "添加共享锁"} #end
      #pragma kcg doc "Graphical_11" {Text = "添加独占锁"} #end
      VOBCorTMCLockCmdProc(
        inSwitchLockType : uint8;
        inSwitchELock_S : SwitchELock_Struct;
        inNumOfSwitchSLock : uint16;
        inSwitchSLockFlag_A : bool^SLOCK_MAX;
        inSwitchSLock_SA : SLock_Struct^SLOCK_MAX;
        inCmdFlag : bool;
        inCmd_S : VOBCLock_CommandData_Struct;
        inSwitchId : uint16;
        inSwitchPosition : uint8;
        inSwitchMoveState : uint8)
      returns (
        outSwitchLockType : uint8 default = inSwitchLockType;
        outSwitchELock_S : SwitchELock_Struct default = inSwitchELock_S;
        outNumOfSwitchSLock : uint16 default = inNumOfSwitchSLock;
        outSwitchSLockFlag_A : bool^SLOCK_MAX default = inSwitchSLockFlag_A;
        outSwitchSLock_SA : SLock_Struct^SLOCK_MAX default = inSwitchSLock_SA)
    var
      CanAdd : bool;
    let
      CanAdd=
        inCmdFlag #1 and inCmd_S#1.LockAdd_Delete #1 = ADD_LOCK #1 and
        inSwitchId #2 = inCmd_S#2.SwitchID #1 and
        inSwitchMoveState #1 <> FLAG_SET;
      activate IfBlock1 if CanAdd
        then if inCmd_S#12.ELcok_SLock #15 = LOCK_E
        then #pragma kcg doc "Graphical_11" {Text = "当前道岔没有锁，直接加独占锁"} #end
        #pragma kcg doc "Graphical_111" {Text = "当前道岔有一把共享锁，清共享锁，加独占锁"} #end
        #pragma kcg doc "Graphical_1111" {Text = "其它情况命令不执行"} #end
        #pragma kcg doc "Graphical_11111" {Text = "当前道岔有独占锁且所属ID为本车"} #end
        let
          activate IfBlock2 if inSwitchLockType #17 = 0
            then var
              _L1 : uint8;
              _L2 : SwitchELock_Struct;
              _L3 : uint8;
              _L4 : uint16;
              _L5 : uint8;
            let
              outSwitchLockType= _L1;
              _L1= LOCK_E;
              outSwitchELock_S= _L2;
              _L2= (#6 make SwitchELock_Struct)(_L4, _L3, _L5);
              _L3= 1_ui8;
              _L4= inCmd_S#14.SourceID;
              _L5= inCmd_S#15.LockPositionNormal_Reverse;
            tel
            else if inSwitchLockType #9 = LOCK_S #5 and
            inNumOfSwitchSLock #10 = 1 #5 and
            inSwitchSLock_SA #18[0].SLockId #11 = inCmd_S#19.SourceID
            then var
              _L4 : uint16;
              _L5 : int32;
              _L6 : bool^SLOCK_MAX;
              _L7 : bool^SLOCK_MAX;
              _L8 : bool;
              _L13 : SwitchELock_Struct;
              _L11 : uint8;
              _L10 : uint8;
              _L14 : uint16;
              _L15 : uint8;
            let
              outNumOfSwitchSLock= _L4;
              _L4= 0_ui16;
              _L5= #1 FindValidSLock(_L6);
              _L6= inSwitchSLockFlag_A;
              _L7= (_L6 #7 with [_L5] = _L8);
              _L8= false;
              outSwitchSLockFlag_A= _L7;
              _L10= LOCK_E;
              _L11= 1_ui8;
              outSwitchELock_S= _L13;
              outSwitchLockType= _L10;
              _L13= (#5 make SwitchELock_Struct)(_L14, _L11, _L15);
              _L14= inCmd_S#20.SourceID;
              _L15= inCmd_S#21.LockPositionNormal_Reverse;
            tel
            else if inSwitchLockType #98 = LOCK_E #44 and
            inSwitchELock_S#33.ELockId #99 = inCmd_S#34.SourceID
            then var
              _L4 : uint8;
              _L6 : SwitchELock_Struct;
              _L7 : SwitchELock_Struct;
              _L10 : uint16;
              _L9 : uint8;
              _L8 : uint8;
            let
              outSwitchELock_S= _L7;
              _L4= inCmd_S#36.LockPositionNormal_Reverse;
              _L6= inSwitchELock_S;
              _L7= (#8 make SwitchELock_Struct)(_L10, _L9, _L4);
              _L10, _L9, _L8= (#1 flatten SwitchELock_Struct)(_L6);
              _= _L8;
            tel
            else let
            tel
          returns ..;
        tel
        else if inCmd_S#13.ELcok_SLock #16 = LOCK_S
        then #pragma kcg doc "Graphical_11" {Text = "当前道岔没有锁，直接加共享锁"} #end
        #pragma kcg doc "Graphical_1111" {Text = "当前道岔有共享锁，先判断是否可以插入新的共享锁，如果可以，插入"} #end
        #pragma kcg doc "Graphical_111" {Text = "当前道岔有车的独占锁，清独占锁，加共享锁"} #end
        var
          tmpPositionValid : bool;
          _L3 : bool;
          _L2 : bool;
          _L1 : bool;
        let
          activate IfBlock2 if inSwitchLockType #80 = 0 #35 and tmpPositionValid
            then var
              _L10 : uint16;
              _L9 : bool^SLOCK_MAX;
              _L8 : uint8;
              _L6 : bool^SLOCK_MAX;
              _L5 : uint16;
              _L4 : bool;
              _L2 : uint8;
              _L1 : SLock_Struct;
              _L11 : SLock_Struct^SLOCK_MAX;
              _L12 : SLock_Struct^SLOCK_MAX;
              _L3 : uint8;
            let
              _L1= (#4 make SLock_Struct)(_L10, _L8, _L2);
              _L2= inCmd_S#8.LockPositionNormal_Reverse;
              outSwitchSLockFlag_A= _L6;
              _L4= true;
              _L5= 1_ui16;
              _L6= (_L9 #5 with [0] = _L4);
              _L8= 1_ui8;
              _L9= inSwitchSLockFlag_A;
              outNumOfSwitchSLock= _L5;
              _L10= inCmd_S#9.SourceID;
              _L11= (_L12 #6 with [0] = _L1);
              outSwitchSLock_SA= _L11;
              _L12= inSwitchSLock_SA;
              outSwitchLockType= _L3;
              _L3= LOCK_S;
            tel
            else if inSwitchLockType #91 = LOCK_E #41 and
            inSwitchELock_S#27.ELockId #92 = inCmd_S#28.SourceID #41 and
            tmpPositionValid
            then var
              _L60 : bool^SLOCK_MAX;
              _L59 : SLock_Struct^SLOCK_MAX;
              _L58 : uint16;
              _L57 : bool^SLOCK_MAX;
              _L56 : bool;
              _L55 : uint8;
              _L54 : SLock_Struct;
              _L53 : SwitchELock_Struct;
              _L52 : uint8;
              _L51 : uint16;
              _L50 : uint8;
              _L49 : uint16;
              _L48 : SLock_Struct^SLOCK_MAX;
              _L47 : uint8;
            let
              outSwitchSLockFlag_A= _L60;
              _L47= 1_ui8;
              outSwitchSLock_SA= _L59;
              _L48= inSwitchSLock_SA;
              _L49= 1_ui16;
              _L50= 0_ui8;
              _L51= 0_ui16;
              outSwitchLockType= _L55;
              _L52= inCmd_S#6.LockPositionNormal_Reverse;
              _L53= (#2 make SwitchELock_Struct)(_L51, _L50, _L50);
              _L54= (#3 make SLock_Struct)(_L58, _L47, _L52);
              _L55= LOCK_S;
              _L56= true;
              outSwitchELock_S= _L53;
              _L57= inSwitchSLockFlag_A;
              _L58= inCmd_S#7.SourceID;
              _L59= (_L48 #3 with [0] = _L54);
              outNumOfSwitchSLock= _L49;
              _L60= (_L57 #4 with [0] = _L56);
            tel
            else if inSwitchLockType #29 = LOCK_S
            then var
              CanInsert : bool;
              InsertIndex : int32;
              _L2 : int32;
              _L1 : bool;
              _L3 : bool^SLOCK_MAX;
              _L4 : SLock_Struct^SLOCK_MAX;
              _L5 : uint16;
            let
              _L1, _L2= #1 GetSLockInsertInfo(_L3, _L4, _L5);
              _L3= inSwitchSLockFlag_A;
              _L4= inSwitchSLock_SA;
              _L5= inCmd_S#3.SourceID;
              CanInsert= _L1;
              InsertIndex= _L2;
              activate IfBlock3 if CanInsert #9 and InsertIndex #3 <> - 1
                then var
                  _L11 : uint8;
                  _L10 : uint16;
                  _L9 : SLock_Struct^SLOCK_MAX;
                  _L8 : SLock_Struct^SLOCK_MAX;
                  _L7 : uint8;
                  _L6 : bool;
                  _L5 : uint16;
                  _L4 : SLock_Struct;
                  _L3 : bool^SLOCK_MAX;
                  _L2 : uint8;
                  _L1 : bool^SLOCK_MAX;
                let
                  _L1= inSwitchSLockFlag_A;
                  _L2= 1_ui8;
                  outSwitchSLock_SA= _L9;
                  _L3= (_L1 #1 with [InsertIndex] = _L6);
                  _L4= (#1 make SLock_Struct)(_L5, _L2, _L11);
                  _L5= inCmd_S#4.SourceID;
                  outSwitchLockType= _L7;
                  outSwitchSLockFlag_A= _L3;
                  _L6= true;
                  _L7= LOCK_S;
                  _L8= inSwitchSLock_SA;
                  outNumOfSwitchSLock= _L10;
                  _L9= (_L8 #2 with [InsertIndex] = _L4);
                  _L10= inNumOfSwitchSLock #1 + 1_ui16;
                  _L11= inCmd_S#5.LockPositionNormal_Reverse;
                tel
                else let
                tel
              returns ..;
            tel
            else let
            tel
          returns ..;
          _L1= _L3 #1 or _L2;
          _L2=
            inSwitchPosition #89 = SWITCH_POSITION_SIDE #40 and
            inCmd_S#26.LockPositionNormal_Reverse #90 = LOCK_SIDE;
          tmpPositionValid= _L1;
          _L3=
            inSwitchPosition #87 = SWITCH_POSITION_MAIN #39 and
            inCmd_S#25.LockPositionNormal_Reverse #88 = LOCK_MAIN;
        tel
        else let
        tel
        else let
        tel
      returns ..;
    tel

    function #pragma kcg doc "Graphical_11" {Text = "添加独占锁"} #end
      #pragma kcg doc "Graphical_1" {Text = "添加共享锁"} #end
      HCOCLockCmdProc(
        inSwitchLockType : uint8;
        inSwitchELock_S : SwitchELock_Struct;
        inNumOfSwitchSLock : uint16;
        inSwitchSLockFlag_A : bool^SLOCK_MAX;
        inSwitchSLock_SA : SLock_Struct^SLOCK_MAX;
        inCmdFlag : bool;
        inCmd_S : ATSLock_CommandData_Struct;
        inSwitchId : uint16;
        inSwitchPosition : uint8;
        inSwitchMoveState : uint8)
      returns (
        outSwitchLockType : uint8 default = inSwitchLockType;
        outSwitchELock_S : SwitchELock_Struct default = inSwitchELock_S;
        outNumOfSwitchSLock : uint16 default = inNumOfSwitchSLock;
        outSwitchSLockFlag_A : bool^SLOCK_MAX default = inSwitchSLockFlag_A;
        outSwitchSLock_SA : SLock_Struct^SLOCK_MAX default = inSwitchSLock_SA)
    var
      CanAdd : bool;
    let
      CanAdd=
        inCmdFlag #1 and inCmd_S#1.LockAdd_Delete #1 = ADD_LOCK #1 and
        inSwitchId #2 = inCmd_S#2.SwitchID #1 and
        inSwitchMoveState #1 <> FLAG_SET;
      activate IfBlock1 if CanAdd
        then if inCmd_S#12.ELcok_SLock #15 = LOCK_E
        then #pragma kcg doc "Graphical_1111" {Text = "其它情况命令不执行"} #end
        #pragma kcg doc "Graphical_111" {Text = "当前道岔有一把ITS共享锁，清共享锁，加独占锁"} #end
        #pragma kcg doc "Graphical_11" {Text = "当前道岔没有锁，直接加独占锁"} #end
        let
          activate IfBlock2 if inSwitchLockType #17 = 0
            then var
              _L1 : uint8;
              _L2 : SwitchELock_Struct;
              _L3 : uint8;
              _L4 : uint16;
              _L5 : uint8;
            let
              outSwitchLockType= _L1;
              _L1= LOCK_E;
              outSwitchELock_S= _L2;
              _L2= (#6 make SwitchELock_Struct)(_L4, _L3, _L5);
              _L3= 1_ui8;
              _L4= inCmd_S#14.SourceID;
              _L5= inCmd_S#15.LockPositionNormal_Reverse;
            tel
            else if inSwitchLockType #9 = LOCK_S #5 and
            inNumOfSwitchSLock #10 = 1 #5 and
            inSwitchSLock_SA #18[0].SLockId #11 = inCmd_S#19.SourceID
            then var
              _L4 : uint16;
              _L5 : int32;
              _L6 : bool^SLOCK_MAX;
              _L7 : bool^SLOCK_MAX;
              _L8 : bool;
              _L13 : SwitchELock_Struct;
              _L11 : uint8;
              _L10 : uint8;
              _L14 : uint16;
              _L15 : uint8;
            let
              outNumOfSwitchSLock= _L4;
              _L4= 0_ui16;
              _L5= #1 FindValidSLock(_L6);
              _L6= inSwitchSLockFlag_A;
              _L7= (_L6 #7 with [_L5] = _L8);
              _L8= false;
              outSwitchSLockFlag_A= _L7;
              _L10= LOCK_E;
              _L11= 1_ui8;
              outSwitchELock_S= _L13;
              outSwitchLockType= _L10;
              _L13= (#5 make SwitchELock_Struct)(_L14, _L11, _L15);
              _L14= inCmd_S#20.SourceID;
              _L15= inCmd_S#21.LockPositionNormal_Reverse;
            tel
            else let
            tel
          returns ..;
        tel
        else if inCmd_S#13.ELcok_SLock #16 = LOCK_S
        then #pragma kcg doc "Graphical_1111" {Text = "当前道岔有共享锁，先判断是否可以插入新的共享锁，如果可以，插入"} #end
        #pragma kcg doc "Graphical_111" {Text = "当前道岔有ITS独占锁，清独占锁，加共享锁"} #end
        #pragma kcg doc "Graphical_11" {Text = "当前道岔没有锁，直接加共享锁"} #end
        var
          tmpPositionValid : bool;
          _L3 : bool;
          _L2 : bool;
          _L1 : bool;
        let
          activate IfBlock2 if inSwitchLockType #80 = 0 #35 and tmpPositionValid
            then var
              _L10 : uint16;
              _L9 : bool^SLOCK_MAX;
              _L8 : uint8;
              _L6 : bool^SLOCK_MAX;
              _L5 : uint16;
              _L4 : bool;
              _L2 : uint8;
              _L1 : SLock_Struct;
              _L11 : SLock_Struct^SLOCK_MAX;
              _L12 : SLock_Struct^SLOCK_MAX;
              _L3 : uint8;
            let
              _L1= (#4 make SLock_Struct)(_L10, _L8, _L2);
              _L2= inCmd_S#8.LockPositionNormal_Reverse;
              outSwitchSLockFlag_A= _L6;
              _L4= true;
              _L5= 1_ui16;
              _L6= (_L9 #5 with [0] = _L4);
              _L8= 1_ui8;
              _L9= inSwitchSLockFlag_A;
              outNumOfSwitchSLock= _L5;
              _L10= inCmd_S#9.SourceID;
              _L11= (_L12 #6 with [0] = _L1);
              outSwitchSLock_SA= _L11;
              _L12= inSwitchSLock_SA;
              outSwitchLockType= _L3;
              _L3= LOCK_S;
            tel
            else if inSwitchLockType #7 = LOCK_E #4 and
            inSwitchSLock_SA #16[0].SLockId #8 = inCmd_S#17.SourceID #4 and
            tmpPositionValid
            then var
              _L60 : bool^SLOCK_MAX;
              _L59 : SLock_Struct^SLOCK_MAX;
              _L58 : uint16;
              _L57 : bool^SLOCK_MAX;
              _L56 : bool;
              _L55 : uint8;
              _L54 : SLock_Struct;
              _L53 : SwitchELock_Struct;
              _L52 : uint8;
              _L51 : uint16;
              _L50 : uint8;
              _L49 : uint16;
              _L48 : SLock_Struct^SLOCK_MAX;
              _L47 : uint8;
            let
              outSwitchSLockFlag_A= _L60;
              _L47= 1_ui8;
              outSwitchSLock_SA= _L59;
              _L48= inSwitchSLock_SA;
              _L49= 1_ui16;
              _L50= 0_ui8;
              _L51= 0_ui16;
              outSwitchLockType= _L55;
              _L52= inCmd_S#6.LockPositionNormal_Reverse;
              _L53= (#2 make SwitchELock_Struct)(_L51, _L50, _L50);
              _L54= (#3 make SLock_Struct)(_L58, _L47, _L52);
              _L55= LOCK_S;
              _L56= true;
              outSwitchELock_S= _L53;
              _L57= inSwitchSLockFlag_A;
              _L58= inCmd_S#7.SourceID;
              _L59= (_L48 #3 with [0] = _L54);
              outNumOfSwitchSLock= _L49;
              _L60= (_L57 #4 with [0] = _L56);
            tel
            else if inSwitchLockType #29 = LOCK_S
            then var
              CanInsert : bool;
              InsertIndex : int32;
              _L2 : int32;
              _L1 : bool;
              _L3 : bool^SLOCK_MAX;
              _L4 : SLock_Struct^SLOCK_MAX;
              _L5 : uint16;
            let
              _L1, _L2= #1 GetSLockInsertInfo(_L3, _L4, _L5);
              _L3= inSwitchSLockFlag_A;
              _L4= inSwitchSLock_SA;
              _L5= inCmd_S#3.SourceID;
              CanInsert= _L1;
              InsertIndex= _L2;
              activate IfBlock3 if CanInsert #9 and InsertIndex #3 <> - 1
                then var
                  _L11 : uint8;
                  _L10 : uint16;
                  _L9 : SLock_Struct^SLOCK_MAX;
                  _L8 : SLock_Struct^SLOCK_MAX;
                  _L7 : uint8;
                  _L6 : bool;
                  _L5 : uint16;
                  _L4 : SLock_Struct;
                  _L3 : bool^SLOCK_MAX;
                  _L2 : uint8;
                  _L1 : bool^SLOCK_MAX;
                let
                  _L1= inSwitchSLockFlag_A;
                  _L2= 1_ui8;
                  outSwitchSLock_SA= _L9;
                  _L3= (_L1 #1 with [InsertIndex] = _L6);
                  _L4= (#1 make SLock_Struct)(_L5, _L2, _L11);
                  _L5= inCmd_S#4.SourceID;
                  outSwitchLockType= _L7;
                  outSwitchSLockFlag_A= _L3;
                  _L6= true;
                  _L7= LOCK_S;
                  _L8= inSwitchSLock_SA;
                  outNumOfSwitchSLock= _L10;
                  _L9= (_L8 #2 with [InsertIndex] = _L4);
                  _L10= 1_ui16;
                  _L11= inCmd_S#5.LockPositionNormal_Reverse;
                tel
                else let
                tel
              returns ..;
            tel
            else let
            tel
          returns ..;
          _L1= _L3 #1 or _L2;
          _L2=
            inSwitchPosition #87 = SWITCH_POSITION_SIDE #39 and
            inCmd_S#25.LockPositionNormal_Reverse #88 = LOCK_SIDE;
          tmpPositionValid= _L1;
          _L3=
            inSwitchPosition #83 = SWITCH_POSITION_MAIN #37 and
            inCmd_S#23.LockPositionNormal_Reverse #84 = LOCK_MAIN;
        tel
        else let
        tel
        else let
        tel
      returns ..;
    tel

    function #pragma kcg doc "Graphical_11" {Text = "添加独占锁"} #end
      #pragma kcg doc "Graphical_1" {Text = "添加共享锁"} #end
      ATSLockCmdProc(
        inSwitchLockType : uint8;
        inSwitchELock_S : SwitchELock_Struct;
        inNumOfSwitchSLock : uint16;
        inSwitchSLockFlag_A : bool^SLOCK_MAX;
        inSwitchSLock_SA : SLock_Struct^SLOCK_MAX;
        inCmdFlag : bool;
        inCmd_S : ATSLock_CommandData_Struct;
        inSwitchId : uint16;
        inSwitchPosition : uint8;
        inSwitchMoveState : uint8)
      returns (
        outSwitchLockType : uint8 default = inSwitchLockType;
        outSwitchELock_S : SwitchELock_Struct default = inSwitchELock_S;
        outNumOfSwitchSLock : uint16 default = inNumOfSwitchSLock;
        outSwitchSLockFlag_A : bool^SLOCK_MAX default = inSwitchSLockFlag_A;
        outSwitchSLock_SA : SLock_Struct^SLOCK_MAX default = inSwitchSLock_SA)
    var
      CanAdd : bool;
    let
      CanAdd=
        inCmdFlag #1 and inCmd_S#1.LockAdd_Delete #1 = ADD_LOCK #1 and
        inSwitchId #2 = inCmd_S#2.SwitchID #1 and
        inSwitchMoveState #1 <> FLAG_SET;
      activate IfBlock1 if CanAdd
        then if inCmd_S#12.ELcok_SLock #15 = LOCK_E
        then #pragma kcg doc "Graphical_1111" {Text = "其它情况命令不执行"} #end
        #pragma kcg doc "Graphical_111" {Text = "当前道岔有一把ITS共享锁，清共享锁，加独占锁"} #end
        #pragma kcg doc "Graphical_11" {Text = "当前道岔没有锁，直接加独占锁"} #end
        let
          activate IfBlock2 if inSwitchLockType #17 = 0
            then var
              _L1 : uint8;
              _L2 : SwitchELock_Struct;
              _L3 : uint8;
              _L4 : uint16;
              _L5 : uint8;
            let
              outSwitchLockType= _L1;
              _L1= LOCK_E;
              outSwitchELock_S= _L2;
              _L2= (#6 make SwitchELock_Struct)(_L4, _L3, _L5);
              _L3= 1_ui8;
              _L4= inCmd_S#14.SourceID;
              _L5= inCmd_S#15.LockPositionNormal_Reverse;
            tel
            else if inSwitchLockType #18 = LOCK_S #5 and
            inNumOfSwitchSLock #19 = 1 #5 and
            inSwitchSLock_SA #16[0].SLockId #20 = ITS_ID
            then var
              _L4 : uint16;
              _L5 : int32;
              _L6 : bool^SLOCK_MAX;
              _L7 : bool^SLOCK_MAX;
              _L8 : bool;
              _L13 : SwitchELock_Struct;
              _L11 : uint8;
              _L10 : uint8;
              _L14 : uint16;
              _L15 : uint8;
            let
              outNumOfSwitchSLock= _L4;
              _L4= 0_ui16;
              _L5= #1 FindValidSLock(_L6);
              _L6= inSwitchSLockFlag_A;
              _L7= (_L6 #7 with [_L5] = _L8);
              _L8= false;
              outSwitchSLockFlag_A= _L7;
              _L10= LOCK_E;
              _L11= 1_ui8;
              outSwitchELock_S= _L13;
              outSwitchLockType= _L10;
              _L13= (#5 make SwitchELock_Struct)(_L14, _L11, _L15);
              _L14= inCmd_S#78.SourceID;
              _L15= inCmd_S#79.LockPositionNormal_Reverse;
            tel
            else let
            tel
          returns ..;
        tel
        else if inCmd_S#13.ELcok_SLock #16 = LOCK_S
        then #pragma kcg doc "Graphical_1111" {Text = "当前道岔有共享锁，先判断是否可以插入新的共享锁，如果可以，插入"} #end
        #pragma kcg doc "Graphical_111" {Text = "当前道岔有ITS独占锁，清独占锁，加共享锁"} #end
        #pragma kcg doc "Graphical_11" {Text = "当前道岔没有锁，直接加共享锁"} #end
        var
          tmpPositionValid : bool;
          _L3 : bool;
          _L2 : bool;
          _L1 : bool;
        let
          activate IfBlock2 if inSwitchLockType #80 = 0 #35 and tmpPositionValid
            then var
              _L10 : uint16;
              _L9 : bool^SLOCK_MAX;
              _L8 : uint8;
              _L6 : bool^SLOCK_MAX;
              _L5 : uint16;
              _L4 : bool;
              _L2 : uint8;
              _L1 : SLock_Struct;
              _L11 : SLock_Struct^SLOCK_MAX;
              _L12 : SLock_Struct^SLOCK_MAX;
              _L3 : uint8;
            let
              _L1= (#4 make SLock_Struct)(_L10, _L8, _L2);
              _L2= inCmd_S#8.LockPositionNormal_Reverse;
              outSwitchSLockFlag_A= _L6;
              _L4= true;
              _L5= 1_ui16;
              _L6= (_L9 #5 with [0] = _L4);
              _L8= 1_ui8;
              _L9= inSwitchSLockFlag_A;
              outNumOfSwitchSLock= _L5;
              _L10= inCmd_S#9.SourceID;
              _L11= (_L12 #6 with [0] = _L1);
              outSwitchSLock_SA= _L11;
              _L12= inSwitchSLock_SA;
              outSwitchLockType= _L3;
              _L3= LOCK_S;
            tel
            else if inSwitchLockType #81 = LOCK_E #36 and
            inSwitchSLock_SA #77[0].SLockId #82 = ITS_ID #36 and
            tmpPositionValid
            then var
              _L60 : bool^SLOCK_MAX;
              _L59 : SLock_Struct^SLOCK_MAX;
              _L58 : uint16;
              _L57 : bool^SLOCK_MAX;
              _L56 : bool;
              _L55 : uint8;
              _L54 : SLock_Struct;
              _L53 : SwitchELock_Struct;
              _L52 : uint8;
              _L51 : uint16;
              _L50 : uint8;
              _L49 : uint16;
              _L48 : SLock_Struct^SLOCK_MAX;
              _L47 : uint8;
            let
              outSwitchSLockFlag_A= _L60;
              _L47= 1_ui8;
              outSwitchSLock_SA= _L59;
              _L48= inSwitchSLock_SA;
              _L49= 1_ui16;
              _L50= 0_ui8;
              _L51= 0_ui16;
              outSwitchLockType= _L55;
              _L52= inCmd_S#6.LockPositionNormal_Reverse;
              _L53= (#2 make SwitchELock_Struct)(_L51, _L50, _L50);
              _L54= (#3 make SLock_Struct)(_L58, _L47, _L52);
              _L55= LOCK_S;
              _L56= true;
              outSwitchELock_S= _L53;
              _L57= inSwitchSLockFlag_A;
              _L58= inCmd_S#7.SourceID;
              _L59= (_L48 #3 with [0] = _L54);
              outNumOfSwitchSLock= _L49;
              _L60= (_L57 #4 with [0] = _L56);
            tel
            else if inSwitchLockType #29 = LOCK_S
            then var
              CanInsert : bool;
              InsertIndex : int32;
              _L2 : int32;
              _L1 : bool;
              _L3 : bool^SLOCK_MAX;
              _L4 : SLock_Struct^SLOCK_MAX;
              _L5 : uint16;
            let
              _L1, _L2= #1 GetSLockInsertInfo(_L3, _L4, _L5);
              _L3= inSwitchSLockFlag_A;
              _L4= inSwitchSLock_SA;
              _L5= inCmd_S#3.SourceID;
              CanInsert= _L1;
              InsertIndex= _L2;
              activate IfBlock3 if CanInsert #9 and InsertIndex #3 <> - 1
                then var
                  _L11 : uint8;
                  _L10 : uint16;
                  _L9 : SLock_Struct^SLOCK_MAX;
                  _L8 : SLock_Struct^SLOCK_MAX;
                  _L7 : uint8;
                  _L6 : bool;
                  _L5 : uint16;
                  _L4 : SLock_Struct;
                  _L3 : bool^SLOCK_MAX;
                  _L2 : uint8;
                  _L1 : bool^SLOCK_MAX;
                let
                  _L1= inSwitchSLockFlag_A;
                  _L2= 1_ui8;
                  outSwitchSLock_SA= _L9;
                  _L3= (_L1 #1 with [InsertIndex] = _L6);
                  _L4= (#1 make SLock_Struct)(_L5, _L2, _L11);
                  _L5= inCmd_S#4.SourceID;
                  outSwitchLockType= _L7;
                  outSwitchSLockFlag_A= _L3;
                  _L6= true;
                  _L7= LOCK_S;
                  _L8= inSwitchSLock_SA;
                  outNumOfSwitchSLock= _L10;
                  _L9= (_L8 #2 with [InsertIndex] = _L4);
                  _L10= 1_ui16;
                  _L11= inCmd_S#5.LockPositionNormal_Reverse;
                tel
                else let
                tel
              returns ..;
            tel
            else let
            tel
          returns ..;
          _L1= _L3 #1 or _L2;
          _L2=
            inSwitchPosition #89 = SWITCH_POSITION_SIDE #40 and
            inCmd_S#83.LockPositionNormal_Reverse #90 = LOCK_SIDE;
          tmpPositionValid= _L1;
          _L3=
            inSwitchPosition #85 = SWITCH_POSITION_MAIN #38 and
            inCmd_S#81.LockPositionNormal_Reverse #86 = LOCK_MAIN;
        tel
        else let
        tel
        else let
        tel
      returns ..;
    tel

    function AddLockManage_each(
        inSwitchLockType : uint8;
        inSwitchELock_S : SwitchELock_Struct;
        inNumOfSwitchSLock : uint16;
        inSwitchSLockFlag_A : bool^SLOCK_MAX;
        inSwitchSLock_SA : SLock_Struct^SLOCK_MAX;
        inSwitchState_S : SwitchState_Struct;
        inSwitchInfo_S : SwitchInfo_Struct;
        inATSCmdFlag_A : bool^CMD_MAX;
        inVOBCCmdFlag_A : bool^CMD_MAX;
        inHCOCCmdFlag_A : bool^CMD_MAX;
        inTMCCmdFlag_A : bool^CMD_MAX;
        inATSCmd_SA : ATSLock_CommandData_Struct^CMD_MAX;
        inVOBCCmd_SA : VOBCLock_CommandData_Struct^CMD_MAX;
        inHCOCCmd_SA : ATSLock_CommandData_Struct^CMD_MAX;
        inTMCCmd_SA : VOBCLock_CommandData_Struct^CMD_MAX)
      returns (
        outSwitchLockType : uint8 default = inSwitchLockType;
        outSwitchELock_S : SwitchELock_Struct default = inSwitchELock_S;
        outNumOfSwitchSLock : uint16 default = inNumOfSwitchSLock;
        outSwitchSLockFlag_A : bool^SLOCK_MAX default = inSwitchSLockFlag_A;
        outSwitchSLock_SA : SLock_Struct^SLOCK_MAX default = inSwitchSLock_SA)
    var
      _L5 : SLock_Struct^SLOCK_MAX;
      _L4 : bool^SLOCK_MAX;
      _L3 : uint16;
      _L2 : SwitchELock_Struct;
      _L1 : uint8;
      _L6 : uint8;
      _L7 : SwitchELock_Struct;
      _L8 : uint16;
      _L9 : bool^SLOCK_MAX;
      _L10 : SLock_Struct^SLOCK_MAX;
      _L11 : uint16^CMD_MAX;
      _L12 : uint8^CMD_MAX;
      _L13 : uint8^CMD_MAX;
      _L14 : bool^CMD_MAX;
      _L15 : ATSLock_CommandData_Struct^CMD_MAX;
      _L16 : uint8;
      _L17 : SwitchELock_Struct;
      _L18 : uint16;
      _L19 : bool^SLOCK_MAX;
      _L20 : SLock_Struct^SLOCK_MAX;
      _L21 : bool^CMD_MAX;
      _L22 : VOBCLock_CommandData_Struct^CMD_MAX;
      _L25 : uint8^CMD_MAX;
      _L24 : uint16^CMD_MAX;
      _L23 : uint8^CMD_MAX;
      _L31 : uint8;
      _L32 : SwitchELock_Struct;
      _L33 : uint16;
      _L34 : bool^SLOCK_MAX;
      _L35 : SLock_Struct^SLOCK_MAX;
      _L36 : bool^CMD_MAX;
      _L37 : ATSLock_CommandData_Struct^CMD_MAX;
      _L40 : uint8^CMD_MAX;
      _L39 : uint8^CMD_MAX;
      _L38 : uint16^CMD_MAX;
      _L51 : uint8;
      _L52 : SwitchELock_Struct;
      _L53 : uint16;
      _L54 : bool^SLOCK_MAX;
      _L55 : SLock_Struct^SLOCK_MAX;
      _L56 : bool^CMD_MAX;
      _L57 : VOBCLock_CommandData_Struct^CMD_MAX;
      _L60 : uint8^CMD_MAX;
      _L59 : uint8^CMD_MAX;
      _L58 : uint16^CMD_MAX;
    let
      _L1, _L2, _L3, _L4, _L5=
        (#2 mapfold 5 #1 ATSLockCmdProc <<CMD_MAX>>)(_L6, _L7, _L8, _L9, _L10,
          _L14, _L15, _L11, _L12, _L13);
      _L6= inSwitchLockType;
      _L7= inSwitchELock_S;
      _L8= inNumOfSwitchSLock;
      _L9= inSwitchSLockFlag_A;
      _L10= inSwitchSLock_SA;
      _L11= (inSwitchState_S#1.Id)#1^CMD_MAX;
      _L12= (inSwitchState_S#2.Position)#2^CMD_MAX;
      _L13= (inSwitchInfo_S#3.MoveState)#3^CMD_MAX;
      _L14= inATSCmdFlag_A;
      _L15= inATSCmd_SA;
      _L16, _L17, _L18, _L19, _L20=
        (#4 mapfold 5 #1 VOBCorTMCLockCmdProc <<CMD_MAX>>)(_L1, _L2, _L3, _L4,
          _L5, _L21, _L22, _L24, _L23, _L25);
      _L21= inVOBCCmdFlag_A;
      _L22= inVOBCCmd_SA;
      _L23= (inSwitchState_S#4.Position)#4^CMD_MAX;
      _L24= (inSwitchState_S#5.Id)#5^CMD_MAX;
      _L25= (inSwitchInfo_S#6.MoveState)#6^CMD_MAX;
      _L31, _L32, _L33, _L34, _L35=
        (#6 mapfold 5 #1 HCOCLockCmdProc <<CMD_MAX>>)(_L16, _L17, _L18, _L19,
          _L20, _L36, _L37, _L38, _L39, _L40);
      _L36= inHCOCCmdFlag_A;
      _L37= inHCOCCmd_SA;
      _L38= (inSwitchState_S#7.Id)#7^CMD_MAX;
      _L39= (inSwitchState_S#8.Position)#8^CMD_MAX;
      _L40= (inSwitchInfo_S#9.MoveState)#9^CMD_MAX;
      _L51, _L52, _L53, _L54, _L55=
        (#8 mapfold 5 #2 VOBCorTMCLockCmdProc <<CMD_MAX>>)(_L31, _L32, _L33,
          _L34, _L35, _L56, _L57, _L58, _L59, _L60);
      _L56= inTMCCmdFlag_A;
      _L57= inTMCCmd_SA;
      _L58= (inSwitchState_S#10.Id)#10^CMD_MAX;
      _L59= (inSwitchState_S#11.Position)#11^CMD_MAX;
      _L60= (inSwitchInfo_S#12.MoveState)#12^CMD_MAX;
      outSwitchLockType= _L51;
      outSwitchELock_S= _L52;
      outNumOfSwitchSLock= _L53;
      outSwitchSLockFlag_A= _L54;
      outSwitchSLock_SA= _L55;
    tel

    function #pragma kcg expand #end
      #pragma kcg separate_io #end GetSLockInsertInfo_each(
        index : int32;
        inInsertIndex : int32;
        inCanInsert : bool;
        inSwitchSLockFlag : bool;
        inSwitchSLock_S : SLock_Struct;
        inSourceId : uint16)
      returns (outCondition : bool; outInsertIndex : int32; outCanInsert : bool)
    var
      _L4 : int32;
      _L5 : int32;
      _L9 : bool;
      _L10 : int32;
      _L11 : bool;
      _L12 : bool;
      _L13 : bool;
      _L14 : bool;
      _L15 : bool;
    let
      _L4= #1 if _L9 then (_L5) else (_L10);
      outInsertIndex= _L4;
      _L5= index;
      _L9= #1 not inSwitchSLockFlag #1 and - 1 #1 = inInsertIndex;
      _L10= inInsertIndex;
      _L11= inSwitchSLock_S#1.SLockId #1 <> inSourceId;
      outCondition= _L11;
      outCanInsert= _L12;
      _L12= #2 if _L11 then (_L13) else (_L14);
      _L13= true;
      _L14= false;
      _L15= inCanInsert;
      _= _L15;
    tel

    function #pragma kcg expand #end
      #pragma kcg separate_io #end GetSLockInsertInfo(
        inSwitchSLockFlag_A : bool^SLOCK_MAX;
        inSwitchSLock_SA : SLock_Struct^SLOCK_MAX;
        inSourceId : uint16)
      returns (outCanInsert : bool; outInsertIndex : int32)
    var
      _L2 : int32;
      _L3 : bool;
      _L4 : bool^SLOCK_MAX;
      _L9 : int32;
      _L12 : bool;
      _L11 : int32;
      _L10 : bool;
      _L14 : SLock_Struct^SLOCK_MAX;
      _L15 : bool;
      _L16 : uint16^SLOCK_MAX;
    let
      _L2, _L10, _L11, _L12=
        (#2 mapfoldwi 2 #1 GetSLockInsertInfo_each <<SLOCK_MAX>> if _L3 default ())(_L9,
          _L15, _L4, _L14, _L16);
      _L3= true;
      _L4= inSwitchSLockFlag_A;
      _L9= - 1;
      _= _L2;
      outInsertIndex= _L11;
      _= _L10;
      outCanInsert= _L12;
      _L14= inSwitchSLock_SA;
      _L15= true;
      _L16= (inSourceId)#1^SLOCK_MAX;
    tel

    function #pragma kcg expand #end
      #pragma kcg separate_io #end FindValidSLock_each(
        index : int32;
        inFindIndex : int32;
        inSwitchSLockFlag : bool)
      returns (outCondition : bool; outFindIndex : int32)
    var
      _L2 : bool;
      _L3 : bool;
      _L4 : int32;
      _L5 : int32;
      _L6 : int32;
      _L7 : int32;
    let
      outCondition= _L3;
      _L2= inSwitchSLockFlag;
      _L3= #1 not _L2;
      _L4= #1 if _L2 then (_L5) else (_L6);
      outFindIndex= _L4;
      _L5= index;
      _L6= - 1;
      _L7= inFindIndex;
      _= _L7;
    tel

    function #pragma kcg expand #end
      #pragma kcg separate_io #end FindValidSLock(
        inSwitchSLockFlag_A : bool^SLOCK_MAX)
      returns (outIndex : int32)
    var
      _L2 : int32;
      _L3 : bool;
      _L4 : bool^SLOCK_MAX;
      _L6 : int32;
      _L9 : int32;
    let
      _L2, _L6= (#2 foldwi #1 FindValidSLock_each <<SLOCK_MAX>> if _L3)(_L9, _L4);
      _L3= true;
      _L4= inSwitchSLockFlag_A;
      _L9= - 1;
      _= _L2;
      outIndex= _L6;
    tel

  end;

  package FaultStateManage
    function #pragma kcg expand #end
      #pragma kcg separate_io #end GetSwitchFaultState_each(
        inAcc : bool;
        inSwitchSLockFlag : bool;
        inSwitchSLock_S : SLock_Struct;
        inSwitchPosition : uint8)
      returns (outCondition : bool; outAcc : bool default = inAcc)
    var
      _L1 : uint8;
      _L2 : bool;
      _L3 : bool;
      _L4 : bool;
      _L5 : uint8;
      _L6 : uint8;
      _L7 : bool;
      _L8 : bool;
      _L9 : bool;
      _L10 : bool;
    let
      _L1= inSwitchPosition;
      _L2= #1 if _L9 then (_L4) else (_L3);
      outAcc= _L2;
      _L3= inAcc;
      _L4= true;
      outCondition= _L10;
      _L5= #1 LockQSwitchStatus2SwitchStatus(_L6);
      _L6= inSwitchSLock_S#1.SLockSwitchState;
      _L7= _L5 #1 <> _L1;
      _L8= inSwitchSLockFlag;
      _L9= _L8 #1 and _L7;
      _L10= #1 not _L9;
    tel

    function #pragma kcg doc "Graphical_1" {Text = "功能：判断道岔是否故障 判断依据：道岔所有共享锁中存储的道岔状态与道岔位置一致"} #end
      #pragma kcg expand #end
      #pragma kcg separate_io #end GetSwitchFaultState(
        inNumOfSwitchSLock : uint16;
        inSwitchSLockFlag_A : bool^SLOCK_MAX;
        inSwitchLock_SA : SLock_Struct^SLOCK_MAX;
        inSwitchPosition : uint8)
      returns (outSwitchFault : uint8)
    var
      _L1 : int32;
      _L3 : bool;
      _L4 : bool;
      _L6 : bool;
      _L8 : uint8^SLOCK_MAX;
      _L9 : uint8;
      _L12 : uint8;
      _L13 : uint8;
      _L18 : SLock_Struct^SLOCK_MAX;
      _L19 : bool^SLOCK_MAX;
    let
      _L1, _L6=
        (#2 foldw #1 GetSwitchFaultState_each <<SLOCK_MAX>> if _L3)(_L4, _L19,
          _L18, _L8);
      _L3= inNumOfSwitchSLock #1 > 0;
      _L4= false;
      _L8= (inSwitchPosition)#1^SLOCK_MAX;
      _= _L1;
      _L9= #1 if _L6 then (_L12) else (_L13);
      outSwitchFault= _L9;
      _L12= SWITCH_FAULT;
      _L13= SWITCH_NORMAL;
      _L18= inSwitchLock_SA;
      _L19= inSwitchSLockFlag_A;
    tel

  end;

  package MoveStateManage
    function #pragma kcg expand #end SwitchSuccess(
        inOCCycle : uint32;
        inSwitchState_S : SwitchState_Struct;
        inSwitchInfo_S : SwitchInfo_Struct;
        inStartFlag : bool)
      returns (outSwitchInfo_S : SwitchInfo_Struct default = inSwitchInfo_S)
    let
      activate IfBlock1 if inStartFlag #1 and
        inSwitchInfo_S#11.MoveState #6 = FLAG_SET
        then if inOCCycle #2 - inSwitchInfo_S#8.SendCycle #2 >
        SWITCH_CHANGE_TIME #1 or
        #4 LockQSwitchStatus2SwitchStatus(inSwitchInfo_S#9.SendCommondState) #5
        =
        inSwitchState_S#10.Position
        then var
          _L1 : SwitchInfo_Struct;
          _L2 : uint32;
          _L3 : uint8;
        let
          outSwitchInfo_S= _L1;
          _L1= (#1 make SwitchInfo_Struct)(_L3, _L3, _L2, _L2, _L2, _L2, _L2);
          _L2= 0_ui32;
          _L3= 0_ui8;
        tel
        else let
        tel
        else let
        tel
      returns ..;
    tel

    function SwitchNeedMove(
        index : uint16;
        inFindIndex : int32;
        inRecvSwitchCmdFlag : bool;
        inRecvSwitchCmd_S : Switch_CommandData_Struct;
        inId : uint16;
        inPosition : uint8;
        inMoveState : uint8;
        inELockId : uint16)
      returns (outFindIndex : int32 default = inFindIndex)
    let
      activate IfBlock1 if inRecvSwitchCmdFlag #1 and
        inRecvSwitchCmd_S#5.SwitchID #4 = inId
        then if inPosition #2 <>
        #1
        LockQSwitchStatus2SwitchStatus(inRecvSwitchCmd_S#3.LockPositionNormal_Reverse)
        then let
          activate IfBlock2 if inMoveState #3 <> FLAG_SET
            then if inELockId #3 = inRecvSwitchCmd_S#4.SourceID
            then var
              _L2 : bool;
              _L1 : uint16;
              _L3 : uint16;
              _L4 : uint16;
              _L6 : int32;
              _L8 : int32;
              _L9 : int32;
              _L7 : uint16;
              _L10 : uint8;
            let
              _L1, _L2= #1 AddSwitchCmd(_L3, _L4, _L10);
              _L3= inRecvSwitchCmd_S#1.SourceID;
              _L4= inRecvSwitchCmd_S#2.SwitchID;
              _= _L1;
              _L6= #1 if _L2 then (_L9) else (_L8);
              outFindIndex= _L6;
              _L8= inFindIndex;
              _L9= (_L7 #1 : int32);
              _L7= index;
              _L10= inRecvSwitchCmd_S#6.LockPositionNormal_Reverse;
            tel
            else let
            tel
            else let
            tel
          returns ..;
        tel
        else let
        tel
        else let
        tel
      returns ..;
    tel

    function imported #pragma kcg keep #end
      #pragma kcg C:name AddSwitchCmd #end AddSwitchCmd(
        SourceID : uint16;
        SwitchID : uint16;
        LockPositionNormal_Reverse : uint8)
      returns (NumOfCmd : uint16; Result : bool);

    function GetSwitchMoveState(
        inOCCycle : uint32;
        inSwitchState_S : SwitchState_Struct;
        inSwitchInfo_S : SwitchInfo_Struct;
        inSwitchELock_S : SwitchELock_Struct;
        inRecvSwitchCmdFlag_A : bool^CMD_MAX;
        inRecvSwitchCmd_SA : Switch_CommandData_Struct^CMD_MAX)
      returns (outSwitchInfo_S : SwitchInfo_Struct)
    var
      FindIndex : int32;
      _L5 : int32;
      _L6 : bool^CMD_MAX;
      _L7 : Switch_CommandData_Struct^CMD_MAX;
      _L8 : uint16^CMD_MAX;
      _L9 : uint8^CMD_MAX;
      _L10 : uint8^CMD_MAX;
      _L11 : uint16^CMD_MAX;
      _L12 : int32;
    let
      _L12=
        (#2 foldi #1 SwitchNeedMove <<CMD_MAX>>)(_L5, _L6, _L7, _L8, _L9, _L10, _L11);
      _L5= - 1;
      _L6= inRecvSwitchCmdFlag_A;
      _L7= inRecvSwitchCmd_SA;
      _L8= (inSwitchState_S#13.Id)#9^CMD_MAX;
      _L9= (inSwitchState_S#12.Position)#8^CMD_MAX;
      _L10= (inSwitchInfo_S#11.MoveState)#7^CMD_MAX;
      _L11= (inSwitchELock_S#14.ELockId)#10^CMD_MAX;
      FindIndex= _L12;
      activate IfBlock1 if FindIndex #1 <> - 1
        then var
          FindCmd : Switch_CommandData_Struct;
          _L1 : Switch_CommandData_Struct;
          _L2 : int32;
          _L3 : Switch_CommandData_Struct^CMD_MAX;
          _L4 : Switch_CommandData_Struct;
          _L5 : SwitchInfo_Struct;
          _L7 : uint8;
          _L8 : uint8;
          _L10 : uint32;
          _L12 : uint32;
          _L11 : uint32;
          _L13 : uint32;
          _L14 : uint32;
        let
          _L1= (_L3#1 . [_L2] default _L4);
          _L2= FindIndex;
          _L3= inRecvSwitchCmd_SA;
          _L4= NULL_Switch_CommandData;
          FindCmd= _L1;
          outSwitchInfo_S= _L5;
          _L5= (#1 make SwitchInfo_Struct)(_L7, _L8, _L10, _L12, _L13, _L14, _L11);
          _L7= FLAG_SET;
          _L8= (FindCmd#5.LockPositionNormal_Reverse #1 : uint8);
          _L10= FindCmd#6.TimeHigh;
          _L11= (FindCmd#7.SourceID #2 : uint32);
          _L12= FindCmd#8.TimeLow;
          _L13= FindCmd#9.CommandID;
          _L14= inOCCycle;
        tel
        else var
          _L1 : SwitchInfo_Struct;
        let
          outSwitchInfo_S= _L1;
          _L1= inSwitchInfo_S;
        tel
      returns ..;
    tel

  end;

  package ATSDeleteLockManage
    function ATSLockDeleteManage_each(
        inOCCycle : uint32;
        inNumOfATSLockDelCmd : uint16;
        inSwitchState_S : SwitchState_Struct;
        inSwitchLockType : uint8;
        inSwitchELock_S : SwitchELock_Struct;
        inNumOfSwitchSLock : uint16;
        inSwitchSLockFlag_A : bool^SLOCK_MAX;
        inATSLockDelCmd_SA : ATSLockDelete_CommandData_Struct^CMD_MAX;
        inATSLockDelCountDown_SA : ATSLockDelete_CountDown_Struct^CMD_MAX)
      returns (
        outSwitchLockType : uint8 default = inSwitchLockType;
        outSwitchELock_S : SwitchELock_Struct default = inSwitchELock_S;
        outNumOfSwitchSLock : uint16 default = inNumOfSwitchSLock;
        outSwitchSLockFlag_A : bool^SLOCK_MAX default = inSwitchSLockFlag_A;
        outATSLockDelCountDown_SA
        : ATSLockDelete_CountDown_Struct^CMD_MAX
        default = inATSLockDelCountDown_SA;
        outEndFlag : bool)
    var
      FindDelLock : bool;
      _L4 : bool;
      _L5 : bool;
      _L6 : uint16^CMD_MAX;
      _L7 : ATSLockDelete_CommandData_Struct^CMD_MAX;
      _L8 : uint16^CMD_MAX;
      _L1 : bool;
      _L3 : uint16;
      _L10 : bool;
    let
      _L4= inNumOfATSLockDelCmd #1 > 0;
      _L5= false;
      _L6= (inNumOfATSLockDelCmd)#1^CMD_MAX;
      _L7= inATSLockDelCmd_SA;
      _L8= (inSwitchState_S#1.Id)#2^CMD_MAX;
      _= _L3;
      FindDelLock= _L1;
      activate IfBlock1 if FindDelLock
        then var
          tmpInsertIndex : int32;
          _L1 : SwitchELock_Struct;
          _L3 : uint8;
          _L4 : uint8;
          _L5 : uint16;
          _L6 : uint16;
          _L7 : bool^SLOCK_MAX;
          _L8 : uint8;
          _L9 : int32;
          _L11 : int32;
          _L12 : int32;
          _L13 : ATSLockDelete_CountDown_Struct^CMD_MAX;
          _L14 : bool;
        let
          outSwitchELock_S= _L1;
          _L1= (#1 make SwitchELock_Struct)(_L5, _L3, _L4);
          _L3= 0_ui8;
          _L4= 0_ui8;
          _L5= 0_ui16;
          outNumOfSwitchSLock= _L6;
          _L6= 0_ui16;
          _L7= (false)#4^SLOCK_MAX;
          outSwitchSLockFlag_A= _L7;
          outSwitchLockType= _L8;
          _L8= 0_ui8;
          _L11, _L9=
            (#3 foldwi #1 FinATSLockDelCountDownInsertLoc <<CMD_MAX>> if _L14)(_L12, _L13);
          _L12= - 1;
          _L13= inATSLockDelCountDown_SA;
          _= _L11;
          tmpInsertIndex= _L9;
          activate IfBlock2 if tmpInsertIndex #1 <> - 1
            then var
              _L1 : ATSLockDelete_CountDown_Struct^CMD_MAX;
              _L2 : ATSLockDelete_CountDown_Struct^CMD_MAX;
              _L3 : int32;
              _L4 : ATSLockDelete_CountDown_Struct;
              _L5 : uint16;
              _L6 : uint32;
            let
              _L1= (_L2 #1 with [_L3] = _L4);
              _L2= inATSLockDelCountDown_SA;
              _L3= tmpInsertIndex;
              _L4= (#2 make ATSLockDelete_CountDown_Struct)(_L5, _L6);
              _L5= inSwitchState_S#3.Id;
              _L6= inOCCycle;
              outATSLockDelCountDown_SA= _L1;
            tel
            else let
            tel
          returns ..;
          _L14= true;
        tel
        else let
        tel
      returns ..;
      _L3, _L1=
        (#2 foldwi #1 FindSwitchByATSLockDelCmd <<CMD_MAX>> if _L4)(_L5, _L6, _L7, _L8);
      outEndFlag= _L10;
      _L10= true;
    tel

    function #pragma kcg expand #end
      #pragma kcg separate_io #end FinATSLockDelCountDownInsertLoc(
        index : int32;
        inFindIndex : int32;
        inATSLockDelCountDown_S : ATSLockDelete_CountDown_Struct)
      returns (outCondition : bool; outFindIndex : int32)
    var
      _L2 : bool;
      _L3 : int32;
      _L4 : int32;
      _L5 : bool;
      _L6 : int32;
    let
      _L2= inATSLockDelCountDown_S#2.SwitchID_ATSQingLing #2 = 0_ui16;
      outFindIndex= _L3;
      _L3= #1 if _L2 then (_L4) else (_L6);
      _L4= index;
      _L5= #1 not _L2;
      outCondition= _L5;
      _L6= inFindIndex;
    tel

    function ATSDeleteLock(
        inOCCycle : uint32;
        inATSLockDelCountDown_S : ATSLockDelete_CountDown_Struct)
      returns (
        outATSLockDelCountDown_S
        : ATSLockDelete_CountDown_Struct
        default = inATSLockDelCountDown_S)
    var
      NeedDel : bool;
      _L1 : uint32;
      _L2 : uint32;
      _L3 : uint32;
      _L4 : bool;
      _L5 : uint32;
      _L6 : bool;
      _L7 : bool;
    let
      _L1= inOCCycle;
      _L2= inATSLockDelCountDown_S#1.Time_ATSQingLing;
      _L3= _L1 #1 - _L2;
      _L4= _L3 #1 >= _L5;
      _L5= ATS_LOCK_ONLY_TIME;
      _L6= inATSLockDelCountDown_S#3.SwitchID_ATSQingLing #1 <> 0;
      _L7= _L6 #1 and _L4;
      NeedDel= _L7;
      activate IfBlock1 if NeedDel
        then var
          _L1 : ATSLockDelete_CountDown_Struct;
          _L2 : uint16;
          _L3 : uint32;
        let
          outATSLockDelCountDown_S= _L1;
          _L1= (#1 make ATSLockDelete_CountDown_Struct)(_L2, _L3);
          _L2= 0_ui16;
          _L3= 0_ui32;
        tel
        else let
        tel
      returns ..;
    tel

    function FindSwitchByATSLockDelCmd(
        index : uint16;
        inFind_ACC : bool;
        inNumOfATSLockDelCmd : uint16;
        inATSLockDelCmd : ATSLockDelete_CommandData_Struct;
        inSwitchId : uint16)
      returns (outCondition : bool; outFind_ACC : bool)
    var
      _L2 : bool;
      _L3 : bool;
      _L5 : bool;
      _L7 : bool;
      _L8 : bool;
      _L9 : bool;
      _L10 : bool;
    let
      _L2= index #1 + 1 #1 < inNumOfATSLockDelCmd;
      _L3= inATSLockDelCmd#1.SwitchID #1 = inSwitchId;
      _L5= inATSLockDelCmd#2.ZeroLable #3 = (FLAG_SET #1 : uint16);
      _L7= _L3 #1 and _L5;
      outFind_ACC= _L7;
      _L8= _L2 #1 or _L9;
      _L9= #1 not _L7;
      outCondition= _L8;
      _L10= inFind_ACC;
      _= _L10;
    tel

  end;

  function SwitchManage(
      inOCCycle : uint32;
      inNumOfSwitch : uint16;
      inSwitchState_SA : SwitchState_Struct^SWITCH_MAX;
      inSwitchInfo_SA : SwitchInfo_Struct^SWITCH_MAX;
      inSwitchLockType_A : uint8^SWITCH_MAX;
      inSwitchELock_SA : SwitchELock_Struct^SWITCH_MAX;
      inNumOfSwitchSLock_A : uint16^SWITCH_MAX;
      inSwitchSLockFlag_AA : bool^SLOCK_MAX^SWITCH_MAX;
      inSwitchSLock_SAA : SLock_Struct^SLOCK_MAX^SWITCH_MAX;
      inNumOfResetCmd : uint16;
      inRecvResetCmd_SA : Switch_Reset_CommandData_Struct^CMD_MAX;
      inATSCmdFlag_A : bool^CMD_MAX;
      inATSCmd_SA : ATSLock_CommandData_Struct^CMD_MAX;
      inVOBCCmdFlag_A : bool^CMD_MAX;
      inVOBCCmd_SA : VOBCLock_CommandData_Struct^CMD_MAX;
      inHCOCCmdFlag_A : bool^CMD_MAX;
      inHCOCCmd_SA : ATSLock_CommandData_Struct^CMD_MAX;
      inTMCCmdFlag_A : bool^CMD_MAX;
      inTMCCmd_SA : VOBCLock_CommandData_Struct^CMD_MAX;
      inSwitchCmdFlag_A : bool^CMD_MAX;
      inSwitchCmd_SA : Switch_CommandData_Struct^CMD_MAX;
      inNumOfATSLockDelCmd : uint16;
      inATSLockDelCmd_SA : ATSLockDelete_CommandData_Struct^CMD_MAX;
      inATSLockDelCountDown_SA : ATSLockDelete_CountDown_Struct^CMD_MAX)
    returns (
      outSwitchFaultState_A : uint8^SWITCH_MAX;
      outSwitchInfo_SA : SwitchInfo_Struct^SWITCH_MAX;
      outSwitchLockType_A : uint8^SWITCH_MAX;
      outSwitchELock_SA : SwitchELock_Struct^SWITCH_MAX;
      outNumOfSwitchSLock_A : uint16^SWITCH_MAX;
      outSwitchSLockFlag_AA : bool^SLOCK_MAX^SWITCH_MAX;
      outSwitchSLock_SAA : SLock_Struct^SLOCK_MAX^SWITCH_MAX;
      outATSLockDelCountDown_SA : ATSLockDelete_CountDown_Struct^CMD_MAX)
  var
    _L8 : bool^SLOCK_MAX^SWITCH_MAX;
    _L7 : uint16^SWITCH_MAX;
    _L6 : SwitchELock_Struct^SWITCH_MAX;
    _L5 : uint8^SWITCH_MAX;
    _L4 : SwitchInfo_Struct^SWITCH_MAX;
    _L3 : uint8^SWITCH_MAX;
    _L2 : ATSLockDelete_CountDown_Struct^CMD_MAX;
    _L9 : uint16;
    _L10 : bool;
    _L11 : uint32^SWITCH_MAX;
    _L12 : uint16^SWITCH_MAX;
    _L13 : SwitchState_Struct^SWITCH_MAX;
    _L14 : SwitchInfo_Struct^SWITCH_MAX;
    _L15 : uint8^SWITCH_MAX;
    _L16 : SwitchELock_Struct^SWITCH_MAX;
    _L18 : bool^SLOCK_MAX^SWITCH_MAX;
    _L19 : SLock_Struct^SLOCK_MAX^SWITCH_MAX;
    _L20 : uint16^SWITCH_MAX;
    _L21 : uint16^SWITCH_MAX;
    _L22 : Switch_Reset_CommandData_Struct^CMD_MAX^SWITCH_MAX;
    _L23 : bool^CMD_MAX^SWITCH_MAX;
    _L25 : bool^CMD_MAX^SWITCH_MAX;
    _L24 : bool^CMD_MAX^SWITCH_MAX;
    _L28 : VOBCLock_CommandData_Struct^CMD_MAX^SWITCH_MAX;
    _L27 : bool^CMD_MAX^SWITCH_MAX;
    _L26 : ATSLock_CommandData_Struct^CMD_MAX^SWITCH_MAX;
    _L33 : ATSLock_CommandData_Struct^CMD_MAX^SWITCH_MAX;
    _L35 : VOBCLock_CommandData_Struct^CMD_MAX^SWITCH_MAX;
    _L34 : bool^CMD_MAX^SWITCH_MAX;
    _L36 : Switch_CommandData_Struct^CMD_MAX^SWITCH_MAX;
    _L38 : ATSLockDelete_CommandData_Struct^CMD_MAX^SWITCH_MAX;
    _L37 : uint16^SWITCH_MAX;
    _L39 : bool;
    _L40 : SLock_Struct^SLOCK_MAX^SWITCH_MAX;
    _L41 : ATSLockDelete_CountDown_Struct^CMD_MAX;
    _L42 : ATSLockDelete_CountDown_Struct^CMD_MAX;
    _L44 : uint32^CMD_MAX;
  let
    _L9, _L39, _L2, _L3, _L4, _L5, _L6, _L7, _L8, _L40=
      (#1 mapfoldwi 1
        #1 SwitchManage_each
        <<SWITCH_MAX>> if _L10 default (SWITCH_NORMAL, NULL_SwitchInfo, 0,
          NULL_SwitchELock, 0, (false)#40^SLOCK_MAX, (
            NULL_SLock)#41^SLOCK_MAX))(_L42, _L11, _L12, _L13, _L14, _L15, _L16,
        _L20, _L18, _L19, _L21, _L22, _L23, _L24, _L25, _L27, _L26, _L28, _L33,
        _L35, _L34, _L36, _L37, _L38);
    _L10= inNumOfSwitch #1 > 0;
    _= _L9;
    outSwitchFaultState_A= _L3;
    outSwitchInfo_SA= _L4;
    outSwitchLockType_A= _L5;
    outSwitchELock_SA= _L6;
    outNumOfSwitchSLock_A= _L7;
    outSwitchSLockFlag_AA= _L8;
    outSwitchSLock_SAA= _L40;
    _L11= (inOCCycle)#1^SWITCH_MAX;
    _L12= (inNumOfSwitch)#3^SWITCH_MAX;
    _L13= inSwitchState_SA;
    _L14= inSwitchInfo_SA;
    _L15= inSwitchLockType_A;
    _L16= inSwitchELock_SA;
    _L18= inSwitchSLockFlag_AA;
    _L19= inSwitchSLock_SAA;
    _L20= inNumOfSwitchSLock_A;
    _L21= (inNumOfResetCmd)#7^SWITCH_MAX;
    _L22= (inRecvResetCmd_SA)#9^SWITCH_MAX;
    _L23= (inATSCmdFlag_A)#20^SWITCH_MAX;
    _L24= (inVOBCCmdFlag_A)#21^SWITCH_MAX;
    _L25= (inHCOCCmdFlag_A)#22^SWITCH_MAX;
    _L26= (inATSCmd_SA)#24^SWITCH_MAX;
    _L27= (inTMCCmdFlag_A)#23^SWITCH_MAX;
    _L28= (inVOBCCmd_SA)#25^SWITCH_MAX;
    _L33= (inHCOCCmd_SA)#30^SWITCH_MAX;
    _L34= (inSwitchCmdFlag_A)#32^SWITCH_MAX;
    _L35= (inTMCCmd_SA)#31^SWITCH_MAX;
    _L36= (inSwitchCmd_SA)#33^SWITCH_MAX;
    _L37= (inNumOfATSLockDelCmd)#38^SWITCH_MAX;
    _L38= (inATSLockDelCmd_SA)#39^SWITCH_MAX;
    _L41= inATSLockDelCountDown_SA;
    _= _L39;
    outATSLockDelCountDown_SA= _L2;
    _L42= (#2 map #1 ATSDeleteLockManage::ATSDeleteLock <<CMD_MAX>>)(_L44, _L41);
    _L44= (inOCCycle)#42^CMD_MAX;
  tel

  function #pragma kcg doc "Graphical_1" {Text = "重置道岔的所有信息"} #end
    #pragma kcg doc "Graphical_11" {Text = "1、通过资源锁控制命令管理道岔的锁信息 2、管理道岔扳动信息 3、管理道岔故障状态"} #end
    SwitchManage_each(
      index : uint16;
      inATSLockDelCountDown_SA : ATSLockDelete_CountDown_Struct^CMD_MAX;
      inOCCycle : uint32;
      inNumOfSwitch : uint16;
      inSwitchState_S : SwitchState_Struct;
      inSwitchInfo_S : SwitchInfo_Struct;
      inSwitchLockType : uint8;
      inSwitchELock_S : SwitchELock_Struct;
      inNumOfSwitchSLock : uint16;
      inSwitchSLockFlag_A : bool^SLOCK_MAX;
      inSwitchSLock_SA : SLock_Struct^SLOCK_MAX;
      inNumOfResetCmd : uint16;
      inRecvResetCmd_SA : Switch_Reset_CommandData_Struct^CMD_MAX;
      inATSCmdFlag_A : bool^CMD_MAX;
      inVOBCCmdFlag_A : bool^CMD_MAX;
      inHCOCCmdFlag_A : bool^CMD_MAX;
      inTMCCmdFlag_A : bool^CMD_MAX;
      inATSCmd_SA : ATSLock_CommandData_Struct^CMD_MAX;
      inVOBCCmd_SA : VOBCLock_CommandData_Struct^CMD_MAX;
      inHCOCCmd_SA : ATSLock_CommandData_Struct^CMD_MAX;
      inTMCCmd_SA : VOBCLock_CommandData_Struct^CMD_MAX;
      inRecvSwitchCmdFlag_A : bool^CMD_MAX;
      inRecvSwitchCmd_SA : Switch_CommandData_Struct^CMD_MAX;
      inNumOfATSLockDelCmd : uint16;
      inATSLockDelCmd_SA : ATSLockDelete_CommandData_Struct^CMD_MAX)
    returns (
      outCondition : bool;
      outATSLockDelCountDown_SA
      : ATSLockDelete_CountDown_Struct^CMD_MAX
      default = inATSLockDelCountDown_SA;
      outSwitchFaultState : uint8;
      outSwitchInfo_S : SwitchInfo_Struct;
      outSwitchLockType : uint8;
      outSwitchELock_S : SwitchELock_Struct;
      outNumOfSwitchSLock : uint16;
      outSwitchSLockFlag_A : bool^SLOCK_MAX;
      outSwitchSLock_SA : SLock_Struct^SLOCK_MAX)
  var
    SwitchNeedReset : bool;
    _L1 : bool;
    _L2 : bool;
    _L4 : uint16;
    _L5 : bool;
    _L6 : uint16^CMD_MAX;
    _L7 : Switch_Reset_CommandData_Struct^CMD_MAX;
    _L8 : uint16^CMD_MAX;
    _L9 : bool;
  let
    _L1= index #2 + 1_ui16 #2 < inNumOfSwitch;
    outCondition= _L1;
    _L4, _L2=
      (#1 foldwi #1 SwitchNeedReset_each <<CMD_MAX>> if _L9)(_L5, _L6, _L7, _L8);
    _L5= false;
    _L6= (inNumOfResetCmd)#1^CMD_MAX;
    _L7= inRecvResetCmd_SA;
    _L8= (inSwitchState_S#1.Id)#2^CMD_MAX;
    _L9= inNumOfResetCmd #1 > 0;
    _= _L4;
    SwitchNeedReset= _L2;
    activate IfBlock1 if SwitchNeedReset
      then var
        _L1 : uint8;
        _L2 : SwitchInfo_Struct;
        _L4 : SwitchELock_Struct;
        _L5 : uint16;
        _L6 : bool^SLOCK_MAX;
        _L7 : SLock_Struct^SLOCK_MAX;
      let
        outSwitchFaultState= _L1;
        outSwitchInfo_S= _L2;
        outSwitchLockType= _L1;
        outSwitchELock_S= _L4;
        outNumOfSwitchSLock= _L5;
        outSwitchSLockFlag_A= _L6;
        outSwitchSLock_SA= _L7;
        _L1= 0_ui8;
        _L2= NULL_SwitchInfo;
        _L4= NULL_SwitchELock;
        _L5= 0_ui16;
        _L6= (false)#3^SLOCK_MAX;
        _L7= (NULL_SLock)#4^SLOCK_MAX;
      tel
      else var
        L_endflag : bool;
        _L24 : SLock_Struct^SLOCK_MAX;
        _L23 : bool^SLOCK_MAX;
        _L22 : uint16;
        _L21 : SwitchELock_Struct;
        _L20 : uint8;
        _L19 : SwitchInfo_Struct;
        _L18 : SwitchState_Struct;
        _L17 : VOBCLock_CommandData_Struct^CMD_MAX;
        _L16 : ATSLock_CommandData_Struct^CMD_MAX;
        _L15 : VOBCLock_CommandData_Struct^CMD_MAX;
        _L14 : ATSLock_CommandData_Struct^CMD_MAX;
        _L13 : bool^CMD_MAX;
        _L12 : bool^CMD_MAX;
        _L11 : bool^CMD_MAX;
        _L10 : bool^CMD_MAX;
        _L9 : bool^SLOCK_MAX;
        _L8 : uint16;
        _L7 : SwitchELock_Struct;
        _L6 : uint8;
        _L46 : SLock_Struct^SLOCK_MAX;
        _L47 : uint8;
        _L48 : uint8;
        _L55 : uint16;
        _L56 : bool^SLOCK_MAX;
        _L57 : SLock_Struct^SLOCK_MAX;
        _L67 : Switch_CommandData_Struct^CMD_MAX;
        _L66 : SwitchInfo_Struct;
        _L65 : SwitchInfo_Struct;
        _L64 : uint32;
        _L63 : SwitchState_Struct;
        _L62 : uint32;
        _L61 : bool^CMD_MAX;
        _L60 : SwitchState_Struct;
        _L59 : SwitchInfo_Struct;
        _L68 : SwitchELock_Struct;
        _L73 : uint32;
        _L78 : bool^SLOCK_MAX;
        _L77 : uint16;
        _L76 : SwitchELock_Struct;
        _L75 : uint8;
        _L79 : uint16;
        _L80 : ATSLockDelete_CommandData_Struct^CMD_MAX;
        _L81 : SwitchState_Struct;
        _L83 : ATSLockDelete_CountDown_Struct^CMD_MAX;
        _L84 : ATSLockDelete_CountDown_Struct^CMD_MAX;
        _L85 : bool;
        _L86 : bool;
      let
        _L24= inSwitchSLock_SA;
        _L23= inSwitchSLockFlag_A;
        _L22= inNumOfSwitchSLock;
        _L21= inSwitchELock_S;
        _L20= inSwitchLockType;
        _L19= inSwitchInfo_S;
        _L18= inSwitchState_S;
        _L17= inTMCCmd_SA;
        _L16= inHCOCCmd_SA;
        _L15= inVOBCCmd_SA;
        _L14= inATSCmd_SA;
        _L13= inTMCCmdFlag_A;
        _L12= inHCOCCmdFlag_A;
        _L11= inVOBCCmdFlag_A;
        _L10= inATSCmdFlag_A;
        _L6, _L7, _L8, _L9, _L46=
          #2 SwitchAddorDelLock(_L20, _L21, _L22, _L23, _L24, _L18, _L19, _L10,
            _L11, _L12, _L13, _L14, _L15, _L16, _L17);
        outSwitchSLock_SA= _L46;
        _L47= #1 FaultStateManage::GetSwitchFaultState(_L55, _L56, _L57, _L48);
        _L48= inSwitchState_S#2.Position;
        outSwitchFaultState= _L47;
        _L55= outNumOfSwitchSLock;
        _L56= outSwitchSLockFlag_A;
        _L57= outSwitchSLock_SA;
        _L59= inSwitchInfo_S;
        _L60= inSwitchState_S;
        _L61= inRecvSwitchCmdFlag_A;
        _L62= inOCCycle;
        outSwitchInfo_S= _L65;
        _L63= inSwitchState_S;
        _L64= inOCCycle;
        _L65=
          #2 MoveStateManage::GetSwitchMoveState(_L62, _L63, _L66, _L68, _L61, _L67);
        _L66= #2 MoveStateManage::SwitchSuccess(_L64, _L60, _L59, _L86);
        _L67= inRecvSwitchCmd_SA;
        _L68= outSwitchELock_S;
        _L73= inOCCycle;
        _L75, _L76, _L77, _L78, _L83, _L85=
          #1 ATSDeleteLockManage::ATSLockDeleteManage_each(_L73, _L79, _L81,
            _L6, _L7, _L8, _L9, _L80, _L84);
        _L79= inNumOfATSLockDelCmd;
        _L80= inATSLockDelCmd_SA;
        _L81= inSwitchState_S;
        outSwitchLockType= _L75;
        outSwitchELock_S= _L76;
        outNumOfSwitchSLock= _L77;
        outSwitchSLockFlag_A= _L78;
        _L84= inATSLockDelCountDown_SA;
        outATSLockDelCountDown_SA= _L83;
        L_endflag= _L85;
        _L86= L_endflag;
      tel
    returns ..;
  tel

  function SwitchNeedReset_each(
      index : uint16;
      inNeedReset : bool;
      inNumOfResetCmd : uint16;
      inRecvResetCmd_S : Switch_Reset_CommandData_Struct;
      inSwitchId : uint16)
    returns (outCondition : bool; outNeedReset : bool)
  var
    _L1 : bool;
    _L2 : bool;
    _L3 : bool;
    _L4 : bool;
    _L5 : bool;
    _L6 : bool;
    _L7 : bool;
  let
    _L1= index #1 + 1 #1 < inNumOfResetCmd;
    _L2= inRecvResetCmd_S#1.SwitchID #1 = inSwitchId;
    _L3= #1 if _L2 then (_L5) else (_L4);
    _L4= inNeedReset;
    _L5= true;
    outNeedReset= _L3;
    _L6= #1 not _L2;
    _L7= _L1 #1 and _L6;
    outCondition= _L7;
  tel

  function SwitchAddorDelLock(
      inSwitchLockType : uint8;
      inSwitchELock_S : SwitchELock_Struct;
      inNumOfSwitchSLock : uint16;
      inSwitchSLockFlag_A : bool^SLOCK_MAX;
      inSwitchSLock_SA : SLock_Struct^SLOCK_MAX;
      inSwitchState_S : SwitchState_Struct;
      inSwitchInfo_S : SwitchInfo_Struct;
      inATSCmdFlag_A : bool^CMD_MAX;
      inVOBCCmdFlag_A : bool^CMD_MAX;
      inHCOCCmdFlag_A : bool^CMD_MAX;
      inTMCCmdFlag_A : bool^CMD_MAX;
      inATSCmd_SA : ATSLock_CommandData_Struct^CMD_MAX;
      inVOBCCmd_SA : VOBCLock_CommandData_Struct^CMD_MAX;
      inHCOCCmd_SA : ATSLock_CommandData_Struct^CMD_MAX;
      inTMCCmd_SA : VOBCLock_CommandData_Struct^CMD_MAX)
    returns (
      outSwitchLockType : uint8;
      outSwitchELock_S : SwitchELock_Struct;
      outNumOfSwitchSLock : uint16;
      outSwitchSLockFlag_A : bool^SLOCK_MAX;
      outSwitchSLock_SA : SLock_Struct^SLOCK_MAX)
  var
    _L39 : SwitchState_Struct;
    _L38 : VOBCLock_CommandData_Struct^CMD_MAX;
    _L37 : SLock_Struct^SLOCK_MAX;
    _L36 : bool^CMD_MAX;
    _L35 : bool^CMD_MAX;
    _L34 : ATSLock_CommandData_Struct^CMD_MAX;
    _L33 : bool^CMD_MAX;
    _L32 : bool^CMD_MAX;
    _L31 : SwitchInfo_Struct;
    _L30 : uint16;
    _L29 : VOBCLock_CommandData_Struct^CMD_MAX;
    _L28 : VOBCLock_CommandData_Struct^CMD_MAX;
    _L27 : SwitchInfo_Struct;
    _L26 : bool^SLOCK_MAX;
    _L25 : VOBCLock_CommandData_Struct^CMD_MAX;
    _L24 : bool^CMD_MAX;
    _L23 : bool^CMD_MAX;
    _L22 : uint8;
    _L21 : ATSLock_CommandData_Struct^CMD_MAX;
    _L20 : bool^CMD_MAX;
    _L19 : SLock_Struct^SLOCK_MAX;
    _L18 : bool^CMD_MAX;
    _L13 : uint8;
    _L14 : SwitchELock_Struct;
    _L15 : uint16;
    _L16 : bool^SLOCK_MAX;
    _L17 : SLock_Struct^SLOCK_MAX;
    _L12 : ATSLock_CommandData_Struct^CMD_MAX;
    _L8 : uint8;
    _L9 : SwitchELock_Struct;
    _L10 : uint16;
    _L11 : bool^SLOCK_MAX;
    _L7 : ATSLock_CommandData_Struct^CMD_MAX;
    _L6 : SwitchELock_Struct;
    _L5 : SwitchState_Struct;
  let
    _L5= inSwitchState_S;
    _L6= inSwitchELock_S;
    _L7= inATSCmd_SA;
    _L8, _L9, _L10, _L11=
      #2 DeleteLockManage::DelLockManage_each(_L18, _L20, _L23, _L35, _L12,
        _L38, _L34, _L25, _L5, _L31, _L22, _L6, _L30, _L26, _L19);
    _L12= inATSCmd_SA;
    _L13, _L14, _L15, _L16, _L17=
      #1 AddLockManage::AddLockManage_each(_L8, _L9, _L10, _L11, _L37, _L39,
        _L27, _L33, _L36, _L32, _L24, _L7, _L28, _L21, _L29);
    _L18= inATSCmdFlag_A;
    _L19= inSwitchSLock_SA;
    _L20= inVOBCCmdFlag_A;
    _L21= inHCOCCmd_SA;
    _L22= inSwitchLockType;
    _L23= inHCOCCmdFlag_A;
    _L24= inTMCCmdFlag_A;
    _L25= inTMCCmd_SA;
    _L26= inSwitchSLockFlag_A;
    _L27= inSwitchInfo_S;
    _L28= inVOBCCmd_SA;
    _L29= inTMCCmd_SA;
    _L30= inNumOfSwitchSLock;
    _L31= inSwitchInfo_S;
    _L32= inHCOCCmdFlag_A;
    _L33= inATSCmdFlag_A;
    _L34= inHCOCCmd_SA;
    _L35= inTMCCmdFlag_A;
    _L36= inVOBCCmdFlag_A;
    _L37= inSwitchSLock_SA;
    _L38= inVOBCCmd_SA;
    _L39= inSwitchState_S;
    outSwitchLockType= _L13;
    outSwitchELock_S= _L14;
    outNumOfSwitchSLock= _L15;
    outSwitchSLockFlag_A= _L16;
    outSwitchSLock_SA= _L17;
  tel

end;


/* xscade source: E:/Work-TCT/6@VBTC_OC/0@SoftwareSource/OC_SCADE20190613/MultSwitchManage.xscade */
package MultSwitchManage
  function AddLock_MultSwitch(
      inCommandNumOfMultSwitch : uint16;
      inwNumOfMultSwitch : uint16;
      inCmdData_SA : MultSwitch_CommandData_Struct^CMD_MAX;
      inMultSWitchData_SA : MultSwitch_Struct^MULTSWITCH_MAX)
    returns (outMultSWitchData_SA : MultSwitch_Struct^MULTSWITCH_MAX)
  var
    _L1 : uint16;
    _L3 : bool;
    _L8 : uint16^MULTSWITCH_MAX;
    _L9 : uint16^MULTSWITCH_MAX;
    _L10 : MultSwitch_CommandData_Struct^CMD_MAX^MULTSWITCH_MAX;
    _L12 : MultSwitch_Struct^MULTSWITCH_MAX;
    _L14 : MultSwitch_Struct^MULTSWITCH_MAX;
  let
    _L1, _L14=
      (#2 mapwi
        #1 AddLock_MultSwitch_C1
        <<MULTSWITCH_MAX>> if _L3 default (NULL_MultSwitch_Struct))(_L8, _L10,
        _L12, _L9);
    _L3= inwNumOfMultSwitch #1 > 0;
    _L8= (inCommandNumOfMultSwitch)#1^MULTSWITCH_MAX;
    _L9= (inwNumOfMultSwitch)#2^MULTSWITCH_MAX;
    _L10= (inCmdData_SA)#3^MULTSWITCH_MAX;
    _L12= inMultSWitchData_SA;
    outMultSWitchData_SA= _L14;
    _= _L1;
  tel

  function AddLock_MultSwitch_C1(
      index : uint16;
      inCommandNumOfMultSwitch : uint16;
      inCmdData_SA : MultSwitch_CommandData_Struct^CMD_MAX;
      inMultSWitchData_S : MultSwitch_Struct;
      inLoopMax : uint16)
    returns (condition : bool; outMultSWitchData_S : MultSwitch_Struct)
  var
    _L1 : uint16;
    _L2 : MultSwitch_CommandData_Struct^CMD_MAX;
    _L3 : MultSwitch_Struct;
    _L5 : bool;
    _L8 : MultSwitch_Struct;
    _L10 : uint16^CMD_MAX;
    _L11 : bool;
  let
    _L1, _L8=
      (#2 foldwi #1 AddLock_MultSwitch_C2 <<CMD_MAX>> if _L5)(_L3, _L2, _L10);
    _L2= inCmdData_SA;
    _L3= inMultSWitchData_S;
    _L5= inCommandNumOfMultSwitch #1 > 0;
    _= _L1;
    outMultSWitchData_S= _L8;
    _L10= (inCommandNumOfMultSwitch)#1^CMD_MAX;
    condition= _L11;
    _L11= index #1 + 1 #1 < inLoopMax;
  tel

  function AddLock_MultSwitch_C2(
      index : uint16;
      inMultSWitchData_S : MultSwitch_Struct;
      inCmdData_S : MultSwitch_CommandData_Struct;
      inLoopMax : uint16)
    returns (
      condition : bool;
      outMultSWitchData_S : MultSwitch_Struct default = inMultSWitchData_S)
  var
    _L1 : bool;
  let
    activate IfBlock1 if inCmdData_S#2.LockAdd_Delete #1 = 0x55
      then if inMultSWitchData_S#63.Id #15 = inCmdData_S#64.MultSwitchID
      then #pragma kcg doc "Graphical_1" {Text = "增加锁"} #end let
        activate IfBlock2 if inMultSWitchData_S#11.ULockNum #5 = 0
          then var
            _L5 : MultSwitch_Struct;
            _L6 : uint8;
            _L7 : uint8;
            _L8 : uint16;
            _L9 : ULock_Struct^SLOCK_MAX;
            _L10 : ULock_Struct^SLOCK_MAX;
            _L12 : ULock_Struct;
            _L14 : uint16;
            _L15 : uint8;
            _L16 : uint8;
            _L36 : bool^SLOCK_MAX;
            _L35 : bool^SLOCK_MAX;
            _L34 : bool;
          let
            _L5= (#3 make MultSwitch_Struct)(_L8, _L7, _L36, _L6, _L9);
            _L6= 1;
            _L7= inCmdData_S#14.Position1_2;
            _L8= inMultSWitchData_S#15.Id;
            _L9= (_L10 #3 with [0] = _L12);
            _L10= inMultSWitchData_S#16.ULockArray;
            _L12= (#4 make ULock_Struct)(_L14, _L15, _L16);
            _L14= inCmdData_S#17.SourceID;
            _L15= 0x01;
            _L16= inCmdData_S#18.Position1_2;
            outMultSWitchData_S= _L5;
            _L34= true;
            _L35= inMultSWitchData_S#19.ULockValidFlag;
            _L36= (_L35 #4 with [0] = _L34);
          tel
          else if inMultSWitchData_S#12.SwitchState #6 =
          inCmdData_S#13.Position1_2
          then var
            tmpULFlag : bool;
            _L2 : bool;
            _L3 : ULock_Struct^SLOCK_MAX;
            _L5 : uint8;
            _L6 : bool;
            _L8 : uint16^SLOCK_MAX;
            _L9 : bool;
            _L12 : uint8^SLOCK_MAX;
            _L13 : bool^SLOCK_MAX;
          let
            _L2= inMultSWitchData_S#1.ULockNum #1 > 0;
            _L3= inMultSWitchData_S#32.ULockArray;
            _L5, _L6=
              (#2 foldwi #1 AddLock_MultSwitch_C3 <<SLOCK_MAX>> if _L2)(_L9,
                _L3, _L13, _L8, _L12);
            _L8= (inCmdData_S#3.SourceID)#1^SLOCK_MAX;
            _L9= false;
            tmpULFlag= _L6;
            activate IfBlock3 if tmpULFlag #8 = false
              then var
                temp_index : uint16;
                _L10 : uint8;
                _L9 : uint16;
                _L8 : uint16;
                _L7 : MultSwitch_Struct;
                _L5 : ULock_Struct;
                _L4 : ULock_Struct^SLOCK_MAX;
                _L2 : ULock_Struct^SLOCK_MAX;
                _L1 : uint8;
                _L12 : uint8;
                _L13 : uint16;
                _L14 : bool^SLOCK_MAX;
                _L16 : bool^SLOCK_MAX;
                _L17 : bool^SLOCK_MAX;
                _L18 : bool;
                _L19 : uint8;
              let
                _L1= 0x01;
                outMultSWitchData_S= _L7;
                _L2= (_L4 #1 with [temp_index] = _L5);
                _L4= inMultSWitchData_S#4.ULockArray;
                _L5= (#1 make ULock_Struct)(_L9, _L1, _L19);
                _L7= (#2 make MultSwitch_Struct)(_L8, _L10, _L17, _L12, _L2);
                _L8= inMultSWitchData_S#5.Id;
                _L9= inCmdData_S#6.SourceID;
                _L10= inMultSWitchData_S#7.SwitchState;
                _L12= inMultSWitchData_S#8.ULockNum #1 + 1;
                _L13= #1 FindULockFlagFalse(_L14);
                _L14= inMultSWitchData_S#9.ULockValidFlag;
                _L16= inMultSWitchData_S#10.ULockValidFlag;
                _L17= (_L16 #2 with [temp_index] = _L18);
                _L18= true;
                _L19= inMultSWitchData_S#35.SwitchState;
                temp_index= _L13;
              tel
              else let
              tel
            returns ..;
            _= _L5;
            _L12= (inMultSWitchData_S#34.ULockNum)#3^SLOCK_MAX;
            _L13= inMultSWitchData_S#36.ULockValidFlag;
          tel
          else #pragma kcg doc "Graphical_1" {Text = "增加交叉渡线共享锁失败:与当前已有交叉渡线状态不一致"} #end
          let
          tel
        returns ..;
      tel
      else #pragma kcg doc "Graphical_1" {Text = "增加交叉渡线资源锁失败:交叉渡线ID不匹配"} #end
      let
      tel
      else let
      tel
    returns ..;
    condition= _L1;
    _L1= index #1 - 1 #1 < inLoopMax;
  tel

  function AddLock_MultSwitch_C3(
      index : uint8;
      inULFlag : bool;
      inULock_S : ULock_Struct;
      inULockValidFlag : bool;
      inSourceId : uint16;
      inLoopMax : uint8)
    returns (condition : bool; outULFlag : bool default = inULFlag)
  var
    _L2 : bool;
  let
    activate IfBlock1 if inULock_S#3.ULockId #3 = inSourceId #2 and
      inULockValidFlag #4 = true
      then var
        _L1 : bool;
      let
        outULFlag= _L1;
        _L1= true;
      tel
      else let
      tel
    returns ..;
    condition= _L2;
    _L2= index #1 + 1 #1 < inLoopMax;
  tel

  function DeleteLock_MultSwitch(
      inCommandNumOfMultSwitch : uint16;
      inwNumOfMultSwitch : uint16;
      inCmdData_SA : MultSwitch_CommandData_Struct^CMD_MAX;
      inMultSWitchData_SA : MultSwitch_Struct^MULTSWITCH_MAX)
    returns (outMultSWitchData_SA : MultSwitch_Struct^MULTSWITCH_MAX)
  var
    _L1 : uint16;
    _L3 : bool;
    _L8 : uint16^MULTSWITCH_MAX;
    _L9 : uint16^MULTSWITCH_MAX;
    _L10 : MultSwitch_CommandData_Struct^CMD_MAX^MULTSWITCH_MAX;
    _L12 : MultSwitch_Struct^MULTSWITCH_MAX;
    _L14 : MultSwitch_Struct^MULTSWITCH_MAX;
  let
    _L1, _L14=
      (#2 mapwi
        #1 DeleteLock_MultSwitch_C1
        <<MULTSWITCH_MAX>> if _L3 default (NULL_MultSwitch_Struct))(_L8, _L10,
        _L12, _L9);
    _L3= inwNumOfMultSwitch #1 > 0;
    _L8= (inCommandNumOfMultSwitch)#1^MULTSWITCH_MAX;
    _L9= (inwNumOfMultSwitch)#2^MULTSWITCH_MAX;
    _L10= (inCmdData_SA)#3^MULTSWITCH_MAX;
    _L12= inMultSWitchData_SA;
    outMultSWitchData_SA= _L14;
    _= _L1;
  tel

  function DeleteLock_MultSwitch_C1(
      index : uint16;
      inCommandNumOfMultSwitch : uint16;
      inCmdData_SA : MultSwitch_CommandData_Struct^CMD_MAX;
      inMultSWitchData_S : MultSwitch_Struct;
      inLoopMax : uint16)
    returns (condition : bool; outMultSWitchData_S : MultSwitch_Struct)
  var
    _L2 : MultSwitch_CommandData_Struct^CMD_MAX;
    _L5 : bool;
    _L10 : uint16^CMD_MAX;
    _L11 : bool;
    _L13 : uint8;
    _L14 : uint8;
    _L15 : bool^SLOCK_MAX;
    _L16 : ULock_Struct^SLOCK_MAX^CMD_MAX;
    _L17 : uint8;
    _L24 : MultSwitch_Struct;
    _L25 : uint16;
    _L26 : ULock_Struct^SLOCK_MAX;
    _L29 : bool^SLOCK_MAX;
    _L31 : uint16;
    _L32 : bool;
    _L33 : uint8;
    _L35 : uint16^CMD_MAX;
  let
    _L31, _L32, _L33, _L29, _L17=
      (#2 mapfoldwi 3 #1 DeleteLock_MultSwitch_C2 <<CMD_MAX>> if _L5 default ())(_L13,
        _L15, _L14, _L35, _L16, _L2, _L10);
    _L2= inCmdData_SA;
    _L5= inCommandNumOfMultSwitch #1 > 0;
    outMultSWitchData_S= _L24;
    _L10= (inCommandNumOfMultSwitch)#1^CMD_MAX;
    condition= _L11;
    _L11= index #1 + 1 #1 < inLoopMax;
    _L13= inMultSWitchData_S#1.SwitchState;
    _L14= inMultSWitchData_S#2.ULockNum;
    _L15= inMultSWitchData_S#3.ULockValidFlag;
    _L16= (inMultSWitchData_S#4.ULockArray)#2^CMD_MAX;
    _L24= (#1 make MultSwitch_Struct)(_L25, _L33, _L29, _L17, _L26);
    _L25= inMultSWitchData_S#5.Id;
    _L26= inMultSWitchData_S#6.ULockArray;
    _L35= (inMultSWitchData_S#7.Id)#3^CMD_MAX;
    _= _L31;
    _= _L32;
  tel

  function DeleteLock_MultSwitch_C2(
      index : uint16;
      inSwitchState : uint8;
      inULockValidFlag : bool^SLOCK_MAX;
      inULockNum : uint8;
      inSwitchId : uint16;
      inULockArray : ULock_Struct^SLOCK_MAX;
      inCmdData_S : MultSwitch_CommandData_Struct;
      inLoopMax : uint16)
    returns (
      condition : bool;
      outSwitchState : uint8 default = inSwitchState;
      outULockValidFlag : bool^SLOCK_MAX default = inULockValidFlag;
      outULockNum : uint8 default = inULockNum)
  var
    _L2 : bool;
  let
    activate IfBlock1 if inCmdData_S#27.LockAdd_Delete #1 = 0xaa
      then if inSwitchId #5 = inCmdData_S#42.MultSwitchID
      then #pragma kcg doc "Graphical_1" {Text = "删除锁"} #end let
        activate IfBlock2 if inCmdData_S#28.SourceID #2 = ITS_ID
          then #pragma kcg doc "Graphical_1" {Text = "ATS发出删除所有锁命令"} #end
          let
            activate IfBlock3 if inCmdData_S#29.All_Self #3 =
              DELETE_ALL_MULT_SWTICH
              then #pragma kcg doc "Graphical_1" {Text = "ATS删除所有交叉渡线资源锁"} #end
              var
                _L4 : uint8;
                _L5 : uint8;
                _L6 : bool^SLOCK_MAX;
              let
                _L4= 0_ui8;
                _L5= 0_ui8;
                _L6= (false)#5^SLOCK_MAX;
                outSwitchState= _L4;
                outULockNum= _L5;
                outULockValidFlag= _L6;
              tel
              else if inCmdData_S#30.All_Self #4 = DELETE_SELF_MULT_SWTICH
              then #pragma kcg doc "Graphical_1" {Text = "ATS删除自身交叉渡线资源锁"} #end
              var
                _L2 : ULock_Struct^SLOCK_MAX;
                _L1 : uint16^SLOCK_MAX;
                _L8 : uint8^SLOCK_MAX;
                _L9 : bool^SLOCK_MAX;
                _L10 : uint8;
                _L14 : uint8;
                _L25 : uint8;
                _L26 : bool^SLOCK_MAX;
                _L21 : uint8;
              let
                _L1= (inCmdData_S#3.SourceID)#3^SLOCK_MAX;
                _L2= inULockArray;
                _L21, _L25, _L26=
                  (#4 mapfold 2 #2 DeleteLock_MultSwitch_C3 <<SLOCK_MAX>>)(_L10,
                    _L14, _L9, _L2, _L1, _L8);
                _L8= (inCmdData_S#4.Position1_2)#4^SLOCK_MAX;
                _L9= inULockValidFlag;
                _L10= inULockNum;
                _L14= inSwitchState;
                outSwitchState= _L25;
                outULockValidFlag= _L26;
                outULockNum= _L21;
              tel
              else #pragma kcg doc "Graphical_1" {Text = "ATS删除交叉渡线资源锁失败"} #end
              let
              tel
            returns ..;
          tel
          else var
            _L9 : uint8;
            _L8 : uint8^SLOCK_MAX;
            _L7 : ULock_Struct^SLOCK_MAX;
            _L4 : uint8;
            _L5 : uint8;
            _L6 : bool^SLOCK_MAX;
            _L3 : uint8;
            _L2 : bool^SLOCK_MAX;
            _L1 : uint16^SLOCK_MAX;
          let
            _L1= (inCmdData_S#1.SourceID)#1^SLOCK_MAX;
            outULockNum= _L4;
            _L2= inULockValidFlag;
            _L3= inSwitchState;
            _L4, _L5, _L6=
              (#2 mapfold 2 #1 DeleteLock_MultSwitch_C3 <<SLOCK_MAX>>)(_L9, _L3,
                _L2, _L7, _L1, _L8);
            outULockValidFlag= _L6;
            _L7= inULockArray;
            _L8= (inCmdData_S#2.Position1_2)#2^SLOCK_MAX;
            outSwitchState= _L5;
            _L9= inULockNum;
          tel
        returns ..;
      tel
      else #pragma kcg doc "Graphical_1" {Text = "删除交叉渡线资源锁失败:交叉渡线ID不匹配"} #end
      let
      tel
      else let
      tel
    returns ..;
    _L2= index #1 + 1 #1 < inLoopMax;
    condition= _L2;
  tel

  function DeleteLock_MultSwitch_C3(
      inULockNum : uint8;
      inSwitchState : uint8;
      inULockValidFlag : bool;
      inULock_S : ULock_Struct;
      inSourceId : uint16;
      inPosition : uint8)
    returns (
      outULockNum : uint8 default = inULockNum;
      outSwitchState : uint8 default = inSwitchState;
      outULockValidFlag : bool default = inULockValidFlag)
  let
    activate IfBlock1 if inULock_S#2.ULockId #3 = inSourceId #1 and
      inULockValidFlag #4 = true
      then if inULock_S#1.ULockSwitchState #1 = inPosition
      then var
        temp_ULockNum : uint8;
        _L4 : bool;
        _L14 : uint8;
        _L16 : uint8;
        _L17 : bool;
        _L18 : uint8;
        _L19 : uint8;
        _L20 : uint8;
      let
        _L4= false;
        temp_ULockNum= _L19 #1 - _L14;
        _L14= 1;
        _L16= #1 if _L17 then (_L18) else (_L20);
        _L17= temp_ULockNum #2 = 0;
        _L18= 0x0;
        _L19= inULockNum;
        outULockNum= temp_ULockNum;
        outSwitchState= _L16;
        _L20= inSwitchState;
        outULockValidFlag= _L4;
      tel
      else #pragma kcg doc "Graphical_1" {Text = "删除失败：要求状态不一致"} #end
      let
      tel
      else #pragma kcg doc "Graphical_1" {Text = "删除失败：资源锁没有此归属ID"} #end
      let
      tel
    returns ..;
  tel

  function FindULockFlagFalse(intULockFlag : bool^SLOCK_MAX)
    returns (outIndex : uint16)
  var
    _L1 : uint16;
    _L3 : bool^SLOCK_MAX;
    _L4 : bool;
    _L5 : uint16;
    _L6 : uint16;
    _L7 : bool^SLOCK_MAX;
  let
    _L1, _L7=
      (#2 mapwi #1 FindULockFlagFalse_C <<SLOCK_MAX>> if _L4 default (false))(_L3);
    _L3= intULockFlag;
    _L4= true;
    outIndex= _L5;
    _L5= _L1 #1 - _L6;
    _L6= 1;
    _= _L7;
  tel

  function FindULockFlagFalse_C(index : uint16; inULockFlag : bool)
    returns (condition : bool; out : bool)
  var
    _L2 : bool;
    _L4 : bool;
    _L7 : bool;
    _L8 : bool;
  let
    condition= _L4;
    _L2= index #1 + 1 #1 < SLOCK_MAX;
    _L4= _L2 #1 and _L7;
    _L7= inULockFlag;
    out= _L8;
    _L8= false;
  tel

end;


/* xscade source: E:/Work-TCT/6@VBTC_OC/0@SoftwareSource/OC_SCADE20190613/HoldTrainManage.xscade */
package HoldTrainManage
  function HoldTrainManage(
      inNumOfHoldTrainCmdData : uint16;
      inHoldTrainCmdDataFlag_A : bool^CMD_MAX;
      inHoldTrainCmdData_SA : HoldTrain_CommandData_Struct^CMD_MAX;
      inNumOfHoldTrainCmd : uint16;
      inHoldTrainCmd_SA : HoldTrain_CommandData_Struct^CMD_MAX)
    returns (
      outNumOfHoldTrainCmdData : uint16 default = inNumOfHoldTrainCmdData;
      outHoldTrainCmdDataFlag_A : bool^CMD_MAX default = inHoldTrainCmdDataFlag_A;
      outHoldTrainCmdData_SA
      : HoldTrain_CommandData_Struct^CMD_MAX
      default = inHoldTrainCmdData_SA)
  var
    _L1 : uint16;
    _L8 : HoldTrain_CommandData_Struct^CMD_MAX;
    _L7 : bool^CMD_MAX;
    _L6 : uint16;
    _L5 : bool;
    _L9 : uint16;
    _L10 : bool^CMD_MAX;
    _L11 : HoldTrain_CommandData_Struct^CMD_MAX;
    _L12 : HoldTrain_CommandData_Struct^CMD_MAX;
    _L13 : uint16^CMD_MAX;
    _L14 : bool;
  let
    _L1, _L5, _L6, _L7, _L8=
      (#1 mapfoldwi 3 #1 HoldTrainManage_each <<CMD_MAX>> if _L14 default ())(_L9,
        _L10, _L11, _L13, _L12);
    _L9= inNumOfHoldTrainCmdData;
    _L10= inHoldTrainCmdDataFlag_A;
    _L11= inHoldTrainCmdData_SA;
    _L12= inHoldTrainCmd_SA;
    _L13= (inNumOfHoldTrainCmd)#1^CMD_MAX;
    _= _L1;
    _= _L5;
    outNumOfHoldTrainCmdData= _L6;
    outHoldTrainCmdDataFlag_A= _L7;
    outHoldTrainCmdData_SA= _L8;
    _L14= inNumOfHoldTrainCmd #1 > 0;
  tel

  function #pragma kcg doc "Graphical_1" {Text = "添加扣车"} #end
    #pragma kcg doc "Graphical_11" {Text = "删除扣车"} #end
    HoldTrainManage_each(
      index : uint16;
      inNumOfHoldTrainCmdData : uint16;
      inHoldTrainCmdDataFlag_A : bool^CMD_MAX;
      inHoldTrainCmdData_SA : HoldTrain_CommandData_Struct^CMD_MAX;
      inNumOfHoldTrainCmd : uint16;
      inHoldTrainCmd_S : HoldTrain_CommandData_Struct)
    returns (
      outCondition : bool;
      outNumOfHoldTrainCmdData : uint16 default = inNumOfHoldTrainCmdData;
      outHoldTrainCmdDataFlag_A : bool^CMD_MAX default = inHoldTrainCmdDataFlag_A;
      outHoldTrainCmdData_SA
      : HoldTrain_CommandData_Struct^CMD_MAX
      default = inHoldTrainCmdData_SA)
  var
    tmpFindIndex : int32;
    _L1 : bool;
    _L5 : int32;
    _L6 : uint16;
    _L7 : uint16;
    _L8 : bool^CMD_MAX;
    _L9 : HoldTrain_CommandData_Struct^CMD_MAX;
  let
    _L1= index #1 + 1 #1 < inNumOfHoldTrainCmd;
    outCondition= _L1;
    _L5= #1 FindHoldTrain(_L6, _L7, _L8, _L9);
    _L6= inHoldTrainCmd_S#1.StationID;
    _L7= inNumOfHoldTrainCmdData;
    _L8= inHoldTrainCmdDataFlag_A;
    _L9= inHoldTrainCmdData_SA;
    tmpFindIndex= _L5;
    activate IfBlock1 if inHoldTrainCmd_S#14.HoldTrainStatus #6 = ADD_HOLD_TRAIN
      #3 and
      tmpFindIndex #7 = - 1
      then var
        tmpInsertIndex : int32;
        _L1 : int32;
        _L2 : bool^CMD_MAX;
      let
        _L1= #1 GetInsertLocation(_L2);
        _L2= inHoldTrainCmdDataFlag_A;
        tmpInsertIndex= _L1;
        activate IfBlock2 if tmpInsertIndex #1 <> - 1
          then var
            _L1 : bool^CMD_MAX;
            _L2 : bool^CMD_MAX;
            _L3 : int32;
            _L4 : bool;
            _L5 : HoldTrain_CommandData_Struct^CMD_MAX;
            _L6 : int32;
            _L7 : HoldTrain_CommandData_Struct^CMD_MAX;
            _L8 : HoldTrain_CommandData_Struct;
            _L9 : uint16;
            _L10 : uint16;
            _L11 : uint16;
            _L12 : uint32;
            _L13 : uint16;
          let
            _L1= inHoldTrainCmdDataFlag_A;
            _L2= (_L1 #1 with [_L3] = _L4);
            _L3= tmpInsertIndex;
            _L4= true;
            outHoldTrainCmdDataFlag_A= _L2;
            _L5= (_L7 #2 with [_L6] = _L8);
            _L6= tmpInsertIndex;
            outHoldTrainCmdData_SA= _L5;
            _L7= inHoldTrainCmdData_SA;
            _L8= (#1 make HoldTrain_CommandData_Struct)(_L9, _L10, _L11, _L12, _L12, _L12);
            _L9= inHoldTrainCmd_S#7.SourceID;
            _L10= inHoldTrainCmd_S#9.StationID;
            _L11= inHoldTrainCmd_S#11.HoldTrainStatus;
            _L12= 0_ui32;
            outNumOfHoldTrainCmdData= _L13;
            _L13= inNumOfHoldTrainCmdData #2 + 1;
          tel
          else let
          tel
        returns ..;
      tel
      else if inHoldTrainCmd_S#15.HoldTrainStatus #8 = DEL_HOLD_TRAIN #4 and
      tmpFindIndex #2 <> - 1
      then var
        _L1 : bool^CMD_MAX;
        _L2 : bool^CMD_MAX;
        _L3 : int32;
        _L4 : bool;
        _L5 : uint16;
      let
        outHoldTrainCmdDataFlag_A= _L2;
        _L1= inHoldTrainCmdDataFlag_A;
        _L2= (_L1 #3 with [_L3] = _L4);
        _L3= tmpFindIndex;
        _L4= false;
        outNumOfHoldTrainCmdData= _L5;
        _L5= inNumOfHoldTrainCmdData #1 - 1;
      tel
      else let
      tel
    returns ..;
  tel

  function #pragma kcg expand #end
    #pragma kcg separate_io #end FindHoldTrain_each(
      index : int32;
      inFindIndex : int32;
      inStationId : uint16;
      inHoldTrainCmdDataFlag : bool;
      inHoldTrainCmdData_S : HoldTrain_CommandData_Struct)
    returns (outCondition : bool; outFindIndex : int32)
  var
    _L1 : bool;
    _L2 : bool;
    _L3 : int32;
    _L4 : int32;
    _L5 : int32;
  let
    _L1=
      inHoldTrainCmdDataFlag #1 and inStationId #1 = inHoldTrainCmdData_S#1.StationID;
    outCondition= _L2;
    _L2= #1 not _L1;
    _L3= #1 if _L1 then (_L4) else (_L5);
    outFindIndex= _L3;
    _L4= index;
    _L5= inFindIndex;
  tel

  function GetInsertLocation(inHoldTrainCmdDataFlag_A : bool^CMD_MAX)
    returns (outInsertIndex : int32)
  var
    _L2 : int32;
    _L3 : bool;
    _L4 : int32;
    _L6 : bool;
    _L7 : int32;
    _L8 : bool^CMD_MAX;
  let
    _L2, _L3, _L4=
      (#1 mapfoldwi 1 #1 GetInsertLocation_each <<CMD_MAX>> if _L6 default ())(_L7,
        _L8);
    _L6= true;
    _L7= - 1;
    _L8= inHoldTrainCmdDataFlag_A;
    _= _L2;
    _= _L3;
    outInsertIndex= _L4;
  tel

  function #pragma kcg expand #end
    #pragma kcg separate_io #end GetInsertLocation_each(
      index : int32;
      inInsertIndex : int32;
      inHoldTrainCmdDataFlag : bool)
    returns (outCondition : bool; outInsertIndex : int32)
  var
    _L1 : bool;
    _L2 : int32;
    _L3 : bool;
    _L4 : int32;
    _L5 : int32;
  let
    _L1= inHoldTrainCmdDataFlag;
    _L2= #1 if _L3 then (_L5) else (_L4);
    _L3= #1 not _L1;
    outInsertIndex= _L2;
    _L4= inInsertIndex;
    _L5= index;
    outCondition= _L1;
  tel

  function FindHoldTrain(
      inStationId : uint16;
      inNumOfHoldTrainCmdData : uint16;
      inHoldTrainCmdDataFlag_A : bool^CMD_MAX;
      inHoldTrainCmdData_SA : HoldTrain_CommandData_Struct^CMD_MAX)
    returns (outFindIndex : int32)
  var
    _L2 : int32;
    _L3 : bool;
    _L4 : int32;
    _L5 : bool;
    _L8 : bool^CMD_MAX;
    _L9 : HoldTrain_CommandData_Struct^CMD_MAX;
    _L10 : uint16^CMD_MAX;
    _L11 : int32;
  let
    _L2, _L3, _L4=
      (#1 mapfoldwi 1 #1 FindHoldTrain_each <<CMD_MAX>> if _L5 default ())(_L11,
        _L10, _L8, _L9);
    _L5= inNumOfHoldTrainCmdData #1 > 0;
    _= _L2;
    _= _L3;
    outFindIndex= _L4;
    _L8= inHoldTrainCmdDataFlag_A;
    _L9= inHoldTrainCmdData_SA;
    _L10= (inStationId)#1^CMD_MAX;
    _L11= - 1;
  tel

end;


/* xscade source: E:/Work-TCT/6@VBTC_OC/0@SoftwareSource/OC_SCADE20190613/JumpTrainManage.xscade */
package JumpTrainManage
  function JumpTrainManage(
      inNumOfJumpTrainCmdData : uint16;
      inJumpTrainCmdDataFlag_A : bool^CMD_MAX;
      inJumpTrainCmdData_SA : JumpTrain_CommandData_Send_Struct^CMD_MAX;
      inNumOfJumpTrainCmd : uint16;
      inJumpTrainCmd_SA : JumpTrain_CommandData_Struct^CMD_MAX)
    returns (
      outNumOfJumpTrainCmdData : uint16;
      outJumpTrainCmdDataFlag_A : bool^CMD_MAX;
      outJumpTrainCmdData_SA : JumpTrain_CommandData_Send_Struct^CMD_MAX)
  var
    _L4 : JumpTrain_CommandData_Send_Struct^CMD_MAX;
    _L3 : bool^CMD_MAX;
    _L2 : uint16;
    _L5 : uint16;
    _L6 : bool;
    _L7 : bool;
    _L8 : uint16;
    _L9 : bool^CMD_MAX;
    _L10 : JumpTrain_CommandData_Send_Struct^CMD_MAX;
    _L11 : uint16^CMD_MAX;
    _L12 : JumpTrain_CommandData_Struct^CMD_MAX;
  let
    _L5, _L6, _L2, _L3, _L4=
      (#1 mapfoldwi 3 #1 JumpTrainManage_each <<CMD_MAX>> if _L7 default ())(_L8,
        _L9, _L10, _L11, _L12);
    _L7= inNumOfJumpTrainCmd #1 > 0;
    _L8= inNumOfJumpTrainCmdData;
    _L9= inJumpTrainCmdDataFlag_A;
    _L10= inJumpTrainCmdData_SA;
    _L11= (inNumOfJumpTrainCmd)#1^CMD_MAX;
    _L12= inJumpTrainCmd_SA;
    outNumOfJumpTrainCmdData= _L2;
    outJumpTrainCmdDataFlag_A= _L3;
    outJumpTrainCmdData_SA= _L4;
    _= _L5;
    _= _L6;
  tel

  function JumpTrainManage_each(
      index : uint16;
      inNumOfJumpTrainCmdData : uint16;
      inJumpTrainCmdDataFlag_A : bool^CMD_MAX;
      inJumpTrainCmdData_SA : JumpTrain_CommandData_Send_Struct^CMD_MAX;
      inNumOfJumpTrainCmd : uint16;
      inJumpTrainCmd_S : JumpTrain_CommandData_Struct)
    returns (
      outCondition : bool;
      outNumOfJumpTrainCmdData : uint16 default = inNumOfJumpTrainCmdData;
      outJumpTrainCmdDataFlag_A : bool^CMD_MAX default = inJumpTrainCmdDataFlag_A;
      outJumpTrainCmdData_SA
      : JumpTrain_CommandData_Send_Struct^CMD_MAX
      default = inJumpTrainCmdData_SA)
  var
    _L1 : bool;
  let
    _L1= index #1 + 1 #1 < inNumOfJumpTrainCmd;
    outCondition= _L1;
    activate IfBlock1 if inJumpTrainCmd_S#2.JumpTrainOrStation #1 =
      JUMP_ALL_TRAIN
      then let
        activate IfBlock2 if inJumpTrainCmd_S#5.JumpTrainStatus #4 =
          ADD_JUMP_TRAIN
          then var
            tmpFindStationId : int32;
            _L1 : int32;
            _L2 : uint16;
            _L3 : uint16;
            _L4 : bool^CMD_MAX;
            _L5 : JumpTrain_CommandData_Send_Struct^CMD_MAX;
          let
            _L1= #1 FindStation(_L2, _L3, _L4, _L5);
            _L2= inJumpTrainCmd_S#8.StationID;
            _L3= inNumOfJumpTrainCmdData;
            _L4= inJumpTrainCmdDataFlag_A;
            _L5= inJumpTrainCmdData_SA;
            tmpFindStationId= _L1;
            activate IfBlock3 if tmpFindStationId #7 = - 1
              then var
                tmpInsertIndex : int32;
                _L1 : int32;
                _L2 : uint16;
                _L3 : bool^CMD_MAX;
              let
                _L1= #1 GetInsertStationIndex(_L2, _L3);
                _L2= inNumOfJumpTrainCmdData;
                _L3= inJumpTrainCmdDataFlag_A;
                tmpInsertIndex= _L1;
                activate IfBlock4 if tmpInsertIndex #2 <> - 1
                  then var
                    _L1 : bool^CMD_MAX;
                    _L2 : bool^CMD_MAX;
                    _L3 : bool;
                    _L4 : int32;
                    _L5 : JumpTrain_CommandData_Send_Struct^CMD_MAX;
                    _L6 : JumpTrain_CommandData_Send_Struct^CMD_MAX;
                    _L7 : JumpTrain_CommandData_Send_Struct;
                    _L8 : uint16;
                    _L11 : uint16;
                    _L12 : uint16^CT_MAX;
                    _L13 : int32;
                    _L14 : uint16;
                  let
                    _L1= inJumpTrainCmdDataFlag_A;
                    _L2= (_L1 #1 with [_L4] = _L3);
                    _L3= true;
                    _L4= tmpInsertIndex;
                    outJumpTrainCmdDataFlag_A= _L2;
                    _L5= (_L6 #2 with [_L13] = _L7);
                    _L6= inJumpTrainCmdData_SA;
                    _L7= (#1 make JumpTrain_CommandData_Send_Struct)(_L8, _L11, _L12);
                    _L8= inJumpTrainCmd_S#9.StationID;
                    _L11= 0_ui16;
                    _L12= (0_ui16)#1^CT_MAX;
                    _L13= tmpInsertIndex;
                    outJumpTrainCmdData_SA= _L5;
                    outNumOfJumpTrainCmdData= _L14;
                    _L14= inNumOfJumpTrainCmdData #2 + 1;
                  tel
                  else let
                  tel
                returns ..;
              tel
              else let
              tel
            returns ..;
          tel
          else if inJumpTrainCmd_S#7.JumpTrainStatus #6 = DEL_JUMP_TRAIN
          then var
            tmpFindDelStationIndex : int32;
            _L1 : int32;
            _L2 : uint16;
            _L3 : uint16;
            _L4 : bool^CMD_MAX;
            _L5 : JumpTrain_CommandData_Send_Struct^CMD_MAX;
          let
            _L1= #2 FindStation(_L2, _L3, _L4, _L5);
            _L2= inJumpTrainCmd_S#11.StationID;
            _L3= inNumOfJumpTrainCmdData;
            _L4= inJumpTrainCmdDataFlag_A;
            _L5= inJumpTrainCmdData_SA;
            tmpFindDelStationIndex= _L1;
            activate IfBlock3 if tmpFindDelStationIndex #3 <> - 1
              then var
                _L1 : bool^CMD_MAX;
                _L2 : uint16;
                _L3 : bool;
                _L4 : bool^CMD_MAX;
                _L5 : int32;
              let
                outJumpTrainCmdDataFlag_A= _L4;
                _L1= inJumpTrainCmdDataFlag_A;
                _L2= inNumOfJumpTrainCmdData #1 - 1;
                outNumOfJumpTrainCmdData= _L2;
                _L3= false;
                _L4= (_L1 #3 with [_L5] = _L3);
                _L5= tmpFindDelStationIndex;
              tel
              else let
              tel
            returns ..;
          tel
          else let
          tel
        returns ..;
      tel
      else if inJumpTrainCmd_S#13.JumpTrainOrStation #9 = JUMP_SPECIFIC_TRAIN
      then let
        activate IfBlock2 if inJumpTrainCmd_S#14.JumpTrainStatus #10 =
          ADD_JUMP_TRAIN
          then var
            tmpFindStationIndex : int32;
            tmpFindTrainIndex : int32;
            tmpInsertIndex : int32;
            _L1 : int32;
            _L2 : uint16;
            _L3 : uint16;
            _L4 : bool^CMD_MAX;
            _L5 : JumpTrain_CommandData_Send_Struct^CMD_MAX;
            _L6 : int32;
            _L7 : int32;
            _L8 : uint16;
          let
            _L1, _L6, _L7= #1 FindTrain(_L2, _L8, _L3, _L4, _L5);
            _L2= inJumpTrainCmd_S#17.StationID;
            _L3= inNumOfJumpTrainCmdData;
            _L4= inJumpTrainCmdDataFlag_A;
            _L5= inJumpTrainCmdData_SA;
            tmpFindStationIndex= _L1;
            activate IfBlock3 if tmpFindStationIndex #8 <> - 1 #2 and
              tmpFindTrainIndex #14 = - 1 #2 and
              tmpInsertIndex #9 <> - 1
              then var
                _L4 : JumpTrain_CommandData_Send_Struct^CMD_MAX;
                _L5 : JumpTrain_CommandData_Send_Struct^CMD_MAX;
                _L7 : int32;
                _L8 : JumpTrain_CommandData_Send_Struct;
                _L9 : JumpTrain_CommandData_Send_Struct^CMD_MAX;
                _L10 : JumpTrain_CommandData_Send_Struct;
                _L11 : int32;
                _L14 : uint16;
                _L13 : uint16;
                _L12 : uint16^CT_MAX;
                _L15 : uint16;
                _L16 : uint16;
                _L17 : uint16^CT_MAX;
                _L19 : int32;
                _L20 : uint16;
              let
                _L4= inJumpTrainCmdData_SA;
                _L5= (_L4 #7 with [_L7] = _L8);
                _L7= tmpFindStationIndex;
                _L8= (#4 make JumpTrain_CommandData_Send_Struct)(_L14, _L16, _L17);
                _L9= inJumpTrainCmdData_SA;
                _L10= (_L9#1 . [_L11] default NULL_JumpTrain_CommandData_Send_Struct);
                _L11= tmpFindStationIndex;
                _L14, _L13, _L12= (#1 flatten JumpTrain_CommandData_Send_Struct)(_L10);
                _L15= 1_ui16;
                _L16= _L13 #4 + _L15;
                _L17= (_L12 #8 with [_L19] = _L20);
                _L19= tmpInsertIndex;
                _L20= inJumpTrainCmd_S#21.JumpTrainID;
                outJumpTrainCmdData_SA= _L5;
              tel
              else let
              tel
            returns ..;
            tmpFindTrainIndex= _L6;
            _L8= inJumpTrainCmd_S#20.JumpTrainID;
            tmpInsertIndex= _L7;
          tel
          else if inJumpTrainCmd_S#15.JumpTrainStatus #11 = DEL_JUMP_TRAIN
          then var
            tmpFindTrainIndex : int32;
            tmpFindStationIndex : int32;
            _L12 : uint16;
            _L11 : JumpTrain_CommandData_Send_Struct^CMD_MAX;
            _L10 : uint16;
            _L7 : int32;
            _L8 : int32;
            _L9 : int32;
            _L6 : bool^CMD_MAX;
            _L13 : uint16;
          let
            activate IfBlock3 if tmpFindStationIndex #11 <> - 1 #3 and
              tmpFindTrainIndex #12 <> - 1
              then var
                _L19 : JumpTrain_CommandData_Send_Struct;
                _L18 : JumpTrain_CommandData_Send_Struct^CMD_MAX;
                _L17 : uint16;
                _L16 : uint16;
                _L15 : uint16;
                _L14 : uint16^CT_MAX;
                _L13 : int32;
                _L12 : JumpTrain_CommandData_Send_Struct^CMD_MAX;
                _L9 : uint16;
                _L10 : uint16;
                _L11 : uint16^CT_MAX;
                _L8 : JumpTrain_CommandData_Send_Struct^CMD_MAX;
                _L7 : int32;
                _L6 : JumpTrain_CommandData_Send_Struct;
                _L20 : int32;
              let
                _L6= (#5 make JumpTrain_CommandData_Send_Struct)(_L9, _L16, _L14);
                _L7= tmpFindStationIndex;
                _L8= (_L12 #10 with [_L13] = _L6);
                _L9, _L10, _L11= (#2 flatten JumpTrain_CommandData_Send_Struct)(_L19);
                _L12= inJumpTrainCmdData_SA;
                _L13= tmpFindStationIndex;
                _L14= (_L11 #9 with [_L20] = _L17);
                _L15= 1_ui16;
                _L16= _L10 #3 - _L15;
                _L17= 0_ui16;
                _L18= inJumpTrainCmdData_SA;
                _L19= (_L18#2 . [_L7] default NULL_JumpTrain_CommandData_Send_Struct);
                _L20= tmpFindTrainIndex;
                outJumpTrainCmdData_SA= _L8;
              tel
              else let
              tel
            returns ..;
            _L6= inJumpTrainCmdDataFlag_A;
            _L7, _L8, _L9= #2 FindTrain(_L10, _L13, _L12, _L6, _L11);
            _L10= inJumpTrainCmd_S#22.StationID;
            _L11= inJumpTrainCmdData_SA;
            _L12= inNumOfJumpTrainCmdData;
            tmpFindStationIndex= _L7;
            tmpFindTrainIndex= _L8;
            _L13= inJumpTrainCmd_S#24.JumpTrainID;
            _= _L9;
          tel
          else let
          tel
        returns ..;
      tel
      else let
      tel
    returns ..;
  tel

  function #pragma kcg expand #end
    #pragma kcg separate_io #end FindStation(
      inStationId : uint16;
      inNumOfJumpTrainCmdData : uint16;
      inJumpTrainCmdDataFlag_A : bool^CMD_MAX;
      inJumpTrainCmdData_SA : JumpTrain_CommandData_Send_Struct^CMD_MAX)
    returns (outFindIndex : int32)
  var
    _L2 : int32;
    _L3 : bool;
    _L4 : bool;
    _L5 : int32;
    _L6 : bool^CMD_MAX;
    _L7 : JumpTrain_CommandData_Send_Struct^CMD_MAX;
    _L8 : int32;
    _L9 : uint16^CMD_MAX;
  let
    _L2, _L3, _L8=
      (#1 mapfoldwi 1 #1 FindStation_each <<CMD_MAX>> if _L4 default ())(_L5,
        _L9, _L6, _L7);
    _L4= inNumOfJumpTrainCmdData #1 > 0;
    _L5= - 1;
    _L6= inJumpTrainCmdDataFlag_A;
    _L7= inJumpTrainCmdData_SA;
    _L9= (inStationId)#1^CMD_MAX;
    _= _L2;
    _= _L3;
    outFindIndex= _L8;
  tel

  function #pragma kcg expand #end
    #pragma kcg separate_io #end FindStation_each(
      index : int32;
      inFindIndex : int32;
      inStationId : uint16;
      inJumpTrainCmdDataFlag : bool;
      inJumpTrainCmdData_S : JumpTrain_CommandData_Send_Struct)
    returns (outCondition : bool; outFindIndex : int32)
  var
    _L1 : bool;
    _L2 : int32;
    _L3 : int32;
    _L4 : int32;
    _L5 : bool;
  let
    _L1=
      inJumpTrainCmdDataFlag #2 and inJumpTrainCmdData_S#1.StationID #1 = inStationId;
    _L2= #1 if _L1 then (_L3) else (_L4);
    _L3= index;
    _L4= inFindIndex;
    outFindIndex= _L2;
    _L5= #1 not _L1;
    outCondition= _L5;
  tel

  function #pragma kcg expand #end
    #pragma kcg separate_io #end FindTrainFromStation(
      inTrainId : uint16;
      inNumOfJumpTrain : uint16;
      inJumpTrain_A : uint16^CT_MAX)
    returns (outFindIndex : int32; outInsertIndex : int32)
  var
    _L3 : int32;
    _L4 : bool;
    _L5 : bool;
    _L6 : int32;
    _L7 : uint16^CT_MAX;
    _L8 : int32;
    _L9 : uint16^CT_MAX;
    _L10 : int32;
  let
    _L3, _L4, _L8, _L10=
      (#1 mapfoldwi 2 #1 FindTrainFromStation_each <<CT_MAX>> if _L5 default ())(_L6,
        _L6, _L7, _L9);
    _L5= inNumOfJumpTrain #1 > 0;
    _L6= - 1;
    _L7= (inTrainId)#1^CT_MAX;
    _L9= inJumpTrain_A;
    _= _L3;
    _= _L4;
    outFindIndex= _L8;
    outInsertIndex= _L10;
  tel

  function #pragma kcg expand #end
    #pragma kcg separate_io #end FindTrainFromStation_each(
      index : int32;
      inFindIndex : int32;
      inInsertIndex : int32;
      inTrainId : uint16;
      inJumpTrain : uint16)
    returns (outCondition : bool; outFindIndex : int32; outInsertIndex : int32)
  var
    _L1 : bool;
    _L2 : int32;
    _L3 : int32;
    _L4 : int32;
    _L5 : bool;
    _L6 : bool;
    _L7 : int32;
    _L8 : int32;
    _L9 : int32;
  let
    _L1= inTrainId #1 = inJumpTrain;
    _L2= #1 if _L1 then (_L3) else (_L4);
    _L3= index;
    _L4= inFindIndex;
    outCondition= _L5;
    _L5= #1 not _L1;
    outFindIndex= _L2;
    _L6= inInsertIndex #1 <> - 1 #1 and inJumpTrain #2 = 0;
    _L7= #2 if _L6 then (_L8) else (_L9);
    _L8= index;
    _L9= inInsertIndex;
    outInsertIndex= _L7;
  tel

  function #pragma kcg expand #end
    #pragma kcg separate_io #end FindTrain(
      inStationId : uint16;
      inTrainId : uint16;
      inNumOfJumpTrainCmdData : uint16;
      inJumpTrainCmdDataFlag_A : bool^CMD_MAX;
      inJumpTrainCmdData_SA : JumpTrain_CommandData_Send_Struct^CMD_MAX)
    returns (
      outFindStationIndex : int32;
      outFindTrainIndex : int32;
      outInsertIndex : int32)
  var
    _L3 : int32;
    _L2 : int32;
    _L4 : int32;
    _L5 : bool;
    _L6 : bool;
    _L7 : int32;
    _L8 : uint16^CMD_MAX;
    _L9 : uint16^CMD_MAX;
    _L10 : bool^CMD_MAX;
    _L11 : JumpTrain_CommandData_Send_Struct^CMD_MAX;
    _L12 : int32;
  let
    _L4, _L5, _L12, _L2, _L3=
      (#1 mapfoldwi 3 #1 FindTrain_each <<CMD_MAX>> if _L6 default ())(_L7, _L7,
        _L7, _L8, _L9, _L10, _L11);
    _L6= inNumOfJumpTrainCmdData #1 > 0;
    _= _L4;
    _= _L5;
    outFindStationIndex= _L12;
    outFindTrainIndex= _L2;
    _L7= - 1;
    _L8= (inStationId)#1^CMD_MAX;
    _L9= (inTrainId)#2^CMD_MAX;
    _L10= inJumpTrainCmdDataFlag_A;
    _L11= inJumpTrainCmdData_SA;
    outInsertIndex= _L3;
  tel

  function #pragma kcg expand #end
    #pragma kcg separate_io #end FindTrain_each(
      index : int32;
      inFindStationIndex : int32;
      inFindTrainIndex : int32;
      inInsertIndex : int32;
      inStationId : uint16;
      inTrainId : uint16;
      inJumpTrainCmdDataFlag : bool;
      inJumpTrainCmdData_S : JumpTrain_CommandData_Send_Struct)
    returns (
      outCondition : bool default = true;
      outFindStationIndex : int32 default = inFindStationIndex;
      outFindTrainIndex : int32 default = inFindTrainIndex;
      outInsertIndex : int32 default = inInsertIndex)
  var
    tmpFindStation : bool;
    _L1 : bool;
  let
    _L1=
      inJumpTrainCmdDataFlag #2 and inJumpTrainCmdData_S#1.StationID #1 = inStationId;
    tmpFindStation= _L1;
    activate IfBlock1 if tmpFindStation
      then var
        _L1 : int32;
        _L2 : uint16;
        _L3 : uint16;
        _L4 : uint16^CT_MAX;
        _L5 : int32;
      let
        _L1, _L5= #1 FindTrainFromStation(_L2, _L3, _L4);
        _L2= inTrainId;
        _L3= inJumpTrainCmdData_S#2.JumpTrainNum;
        _L4= inJumpTrainCmdData_S#3.JumpTrainIDArray;
        activate IfBlock2 if outFindTrainIndex #1 <> - 1
          then var
            _L1 : int32;
            _L2 : bool;
          let
            _L1= index;
            outFindStationIndex= _L1;
            outCondition= _L2;
            _L2= false;
          tel
          else let
          tel
        returns ..;
        outFindTrainIndex= _L1;
        outInsertIndex= _L5;
      tel
      else let
      tel
    returns ..;
  tel

  function #pragma kcg expand #end
    #pragma kcg separate_io #end GetInsertStationIndex(
      inNumOfJumpTrainCmdData : uint16;
      inJumpTrainCmdDataFlag_A : bool^CMD_MAX)
    returns (outInsertIndex : int32)
  var
    _L1 : int32;
    _L3 : int32;
    _L5 : bool;
    _L6 : int32;
    _L7 : bool^CMD_MAX;
  let
    _L3, _L1=
      (#1 foldwi #1 GetInsertStationIndex_each <<CMD_MAX>> if _L5)(_L6, _L7);
    _L5= inNumOfJumpTrainCmdData #1 > 0;
    _L6= - 1;
    _= _L3;
    outInsertIndex= _L1;
    _L7= inJumpTrainCmdDataFlag_A;
  tel

  function #pragma kcg expand #end
    #pragma kcg separate_io #end GetInsertStationIndex_each(
      index : int32;
      inInsertIndex : int32;
      inJumpTrainCmdDataFlag : bool)
    returns (outCondition : bool; outInsertIndex : int32)
  var
    _L2 : bool;
    _L3 : int32;
    _L4 : bool;
    _L5 : int32;
    _L6 : int32;
  let
    _L2= #1 not inJumpTrainCmdDataFlag;
    _L3= #1 if _L2 then (_L5) else (_L6);
    _L4= #2 not _L2;
    outCondition= _L4;
    _L5= index;
    _L6= inInsertIndex;
    outInsertIndex= _L3;
  tel

end;


/* xscade source: E:/Work-TCT/6@VBTC_OC/0@SoftwareSource/OC_SCADE20190613/TSRManage.xscade */
package TSRManage
  function TSRManage(
      inTMCInputFlag : uint8;
      inNumOfTsrCtrlCmd : uint16;
      inTsrCtrlCmd_SA : TSR_CTRL_CommandData_Struct^CMD_MAX;
      inNumOfTsrData : uint16;
      inTsrData_SA : TSR_Struct^TSR_MAX)
    returns (
      outTsrValidFlag : uint8;
      outNumOfTsrData : uint16;
      outTsrData_SA : TSR_Struct^TSR_MAX)
  var
    _L1 : bool;
    _L6 : uint16;
    _L8 : uint16;
    _L10 : TSR_Struct^TSR_MAX;
    _L12 : TSR_Struct^TSR_MAX;
    _L15 : TSR_Struct^TSR_MAX;
    _L14 : uint16;
    _L16 : uint16;
    _L17 : bool;
    _L18 : bool;
    _L19 : uint16^CMD_MAX;
    _L20 : TSR_CTRL_CommandData_Struct^CMD_MAX;
    _L3 : TSR_Struct^TSR_MAX;
    _L2 : uint16;
  let
    _L1=
      inNumOfTsrCtrlCmd #4 <> 0_ui16 #3 and
      inTsrCtrlCmd_SA #3[0].TSRFlag #6 = TSR_SET;
    _L6= 0_ui16;
    _L8= inNumOfTsrData;
    _L10= inTsrData_SA;
    _L12= (NULL_TsrData)#5^TSR_MAX;
    _L16, _L17, _L14, _L15=
      (#1 mapfoldwi 2 #1 TSRManage_each <<CMD_MAX>> if _L18 default ())(_L2,
        _L3, _L19, _L20);
    _L18= inNumOfTsrCtrlCmd #1 > 0;
    _L19= (inNumOfTsrCtrlCmd)#4^CMD_MAX;
    _L20= inTsrCtrlCmd_SA;
    _= _L16;
    _= _L17;
    outNumOfTsrData= _L14;
    outTsrData_SA= _L15;
    activate IfBlock1 if inTMCInputFlag #3 = FLAG_SET
      then if outNumOfTsrData #5 = 0_ui16
      then let
        outTsrValidFlag= FLAG_UNSET;
      tel
      else let
        outTsrValidFlag= FLAG_SET;
      tel
      else let
        outTsrValidFlag= 0xFF;
      tel
    returns ..;
    _L2, _L3= #1 if _L1 then (_L6, _L12) else (_L8, _L10);
  tel

  function TSRManage_each(
      index : uint16;
      inNumOfTsrData : uint16;
      inTsrData_SA : TSR_Struct^TSR_MAX;
      inNumOfTsrCtrlCmd : uint16;
      inTsrCtrlCmd_S : TSR_CTRL_CommandData_Struct)
    returns (
      outCondition : bool;
      outNumOfTsrData : uint16 default = inNumOfTsrData;
      outTsrData_SA : TSR_Struct^TSR_MAX default = inTsrData_SA)
  var
    _L1 : bool;
  let
    activate IfBlock1 if inTsrCtrlCmd_S#25.TSRFlag #3 = TSR_SET
      then var
        _L2 : uint16;
        _L3 : TSR_Struct^TSR_MAX;
        _L4 : TSR_Struct^TSR_MAX;
        _L5 : uint16;
        _L7 : TSR_Struct;
        _L8 : uint8;
        _L16 : uint8;
        _L17 : uint8;
        _L18 : uint16^TSR_SECTION_MAX;
      let
        outNumOfTsrData= _L2;
        _L2= inNumOfTsrData #1 + 1;
        _L3= inTsrData_SA;
        _L4= (_L3 #1 with [_L5] = _L7);
        _L5= inNumOfTsrData;
        outTsrData_SA= _L4;
        _L7= (#1 make TSR_Struct)(_L8, _L16, _L17, _L18);
        _L8= inTsrCtrlCmd_S#4.TSRSpeed;
        _L16= 0_ui8;
        _L17= inTsrCtrlCmd_S#20.TSRSectionNum;
        _L18= inTsrCtrlCmd_S#22.TSRSectionIdBuf;
      tel
      else if inTsrCtrlCmd_S#26.TSRFlag #4 = TSR_CANCEL
      then var
        _L1 : uint16;
        _L2 : TSR_Struct^TSR_MAX;
      let
        outNumOfTsrData= _L1;
        _L1= 0_ui16;
        outTsrData_SA= _L2;
        _L2= (NULL_TsrData)#2^TSR_MAX;
      tel
      else let
      tel
    returns ..;
    _L1= index #2 + 1 #1 < inNumOfTsrCtrlCmd;
    outCondition= _L1;
  tel

end;


/* xscade source: E:/Work-TCT/6@VBTC_OC/0@SoftwareSource/OC_SCADE20190613/PhySecBlockManage.xscade */
package PhySecBlockManage
  function PhySecBlockManage(
      inPhySecBlockIdFlag_A : uint8^PHYSEC_MAX;
      inPhySecBlockId_A : uint16^PHYSEC_MAX;
      inNumOfPhySecBlockCmd : uint16;
      inRecvPhySecBlockCmd_SA : PhySec_Block_CommandData_Struct^CMD_MAX)
    returns (
      outPhySecBlockIdFlag_A : uint8^PHYSEC_MAX default = inPhySecBlockIdFlag_A;
      outPhySecBlockId_A : uint16^PHYSEC_MAX default = inPhySecBlockId_A)
  var
    _L13 : uint16;
    _L14 : bool;
    _L12 : PhySec_Block_CommandData_Struct^CMD_MAX;
    _L11 : uint8^PHYSEC_MAX;
    _L10 : uint16^PHYSEC_MAX;
    _L9 : uint16^CMD_MAX;
    _L6 : bool;
    _L17 : uint16^PHYSEC_MAX;
    _L18 : uint8^PHYSEC_MAX;
  let
    _= _L13;
    outPhySecBlockId_A= _L17;
    _L6= inNumOfPhySecBlockCmd #1 > 0;
    outPhySecBlockIdFlag_A= _L18;
    _= _L14;
    _L9= (inNumOfPhySecBlockCmd)#3^CMD_MAX;
    _L10= inPhySecBlockId_A;
    _L11= inPhySecBlockIdFlag_A;
    _L12= inRecvPhySecBlockCmd_SA;
    _L13, _L14, _L18, _L17=
      (#2 mapfoldwi 2 #1 PhySecBlockManage_each1 <<CMD_MAX>> if _L6 default ())(_L11,
        _L10, _L9, _L12);
  tel

  function PhySecBlockManage_each1(
      index : uint16;
      inPhySecBlockIdFlag_A : uint8^PHYSEC_MAX;
      inPhySecBlockId_A : uint16^PHYSEC_MAX;
      inNumOfCmd : uint16;
      inRecvPhySecBlockCmd_S : PhySec_Block_CommandData_Struct)
    returns (
      outCondition : bool;
      outPhySecBlockIdFlag_A : uint8^PHYSEC_MAX default = inPhySecBlockIdFlag_A;
      outPhySecBlockId_A : uint16^PHYSEC_MAX default = inPhySecBlockId_A)
  var
    _L1 : bool;
  let
    _L1= index #1 + 1 #1 < inNumOfCmd;
    activate IfBlock2 if inRecvPhySecBlockCmd_S#10.BlockLable #10 =
      PHYSEC_BLOCK_SET
      then var
        FindIdFlag : bool;
        _L1 : uint8^PHYSEC_MAX;
        _L2 : uint16^PHYSEC_MAX;
        _L3 : uint16;
        _L4 : bool;
        _L13 : uint16^PHYSEC_MAX;
        _L15 : bool;
        _L16 : bool;
      let
        _L1= inPhySecBlockIdFlag_A;
        _L2= inPhySecBlockId_A;
        _L3, _L16=
          (#1 foldwi #1 PhySecBlockManage_each2 <<PHYSEC_MAX>> if _L4)(_L15,
            _L1, _L2, _L13);
        _L4= true;
        _= _L3;
        _L13= (inRecvPhySecBlockCmd_S#15.PhySecId)#1^PHYSEC_MAX;
        _L15= false;
        FindIdFlag= _L16;
        activate IfBlock1 if FindIdFlag
          then let
          tel
          else var
            index : int32;
            _L2 : uint8^PHYSEC_MAX;
            _L1 : int32;
          let
            activate IfBlock3 if index #1 <> - 1
              then var
                _L1 : uint8^PHYSEC_MAX;
                _L2 : uint8^PHYSEC_MAX;
                _L3 : uint8;
                _L4 : uint16^PHYSEC_MAX;
                _L5 : uint16^PHYSEC_MAX;
                _L6 : uint16;
              let
                _L1= (_L2 #1 with [index] = _L3);
                _L2= inPhySecBlockIdFlag_A;
                _L3= 1_ui8;
                outPhySecBlockIdFlag_A= _L1;
                _L4= (_L5 #2 with [index] = _L6);
                _L5= inPhySecBlockId_A;
                outPhySecBlockId_A= _L4;
                _L6= inRecvPhySecBlockCmd_S#13.PhySecId;
              tel
              else let
              tel
            returns ..;
            index= _L1;
            _L2= inPhySecBlockIdFlag_A;
            _L1= #1 FindInsertIndexPhySecBlock(_L2);
          tel
        returns ..;
      tel
      else if inRecvPhySecBlockCmd_S#11.BlockLable #11 = PHYSEC_BLOCK_RELIEVE
      then var
        FindIdFlag : bool;
        index : uint16;
        _L8 : bool;
        _L7 : uint8^PHYSEC_MAX;
        _L4 : uint16;
        _L3 : uint16^PHYSEC_MAX;
        _L2 : bool;
        _L1 : uint16^PHYSEC_MAX;
        _L9 : bool;
      let
        _L1= (inRecvPhySecBlockCmd_S#16.PhySecId)#2^PHYSEC_MAX;
        _L2= true;
        _L3= inPhySecBlockId_A;
        _L4, _L9=
          (#5 foldwi #3 PhySecBlockManage_each2 <<PHYSEC_MAX>> if _L2)(_L8, _L7,
            _L3, _L1);
        _L7= inPhySecBlockIdFlag_A;
        _L8= false;
        FindIdFlag= _L9;
        index= _L4;
        activate IfBlock1 if FindIdFlag
          then var
            _L1 : uint8^PHYSEC_MAX;
            _L2 : uint8^PHYSEC_MAX;
            _L3 : uint8;
          let
            _L1= (_L2 #3 with [index #1 - 1] = _L3);
            _L2= inPhySecBlockIdFlag_A;
            _L3= 0_ui8;
            outPhySecBlockIdFlag_A= _L1;
          tel
          else let
          tel
        returns ..;
      tel
      else let
      tel
    returns ..;
    outCondition= _L1;
  tel

  function PhySecBlockManage_each2(
      index : uint16;
      inFindIdFlag : bool;
      inPhySecBlockIdFlag : uint8;
      inPhySecBlockId : uint16;
      inRecvPhySecBlockId : uint16)
    returns (outCondition : bool; outFindIdFlag : bool default = inFindIdFlag)
  var
    _L1 : bool;
    _L2 : bool;
    _L3 : bool;
    _L4 : bool;
  let
    outCondition= _L4;
    _L1= index #5 + 1 #5 < PHYSEC_MAX;
    _L2= inRecvPhySecBlockId #4 = inPhySecBlockId #4 and inPhySecBlockIdFlag #5 = 1;
    _L3= #1 not _L2;
    _L4= _L1 #3 and _L3;
    activate IfBlock1 if inRecvPhySecBlockId #6 = inPhySecBlockId #5 and
      inPhySecBlockIdFlag #7 = 1
      then var
        _L1 : bool;
      let
        outFindIdFlag= _L1;
        _L1= true;
      tel
      else let
      tel
    returns ..;
  tel

  function #pragma kcg expand #end FindInsertIndexPhySecBlock_each(
      index : int32;
      inFindIndex : int32;
      inPhySecFlag : uint8)
    returns (outCondition : bool; outFindIndex : int32)
  var
    _L1 : int32;
    _L2 : bool;
    _L4 : int32;
    _L5 : int32;
    _L6 : bool;
  let
    _L1= #1 if _L2 then (_L5) else (_L4);
    _L2= inPhySecFlag #1 = 0;
    _L4= inFindIndex;
    _L5= index;
    outCondition= _L6;
    outFindIndex= _L1;
    _L6= #1 not _L2;
  tel

  function #pragma kcg doc "Graphical_1" {Text = "在封锁物理区段表中查找可以插入的位置，如果找到返回存储的位置索引，否则返回-1"} #end
    #pragma kcg separate_io #end FindInsertIndexPhySecBlock(
      inPhySecBlockIdFlag_A : uint8^PHYSEC_MAX)
    returns (outFindIndex : int32)
  var
    _L1 : int32;
    _L3 : int32;
    _L4 : bool;
    _L5 : int32;
    _L9 : uint8^PHYSEC_MAX;
  let
    _L3, _L1=
      (#2 foldwi #1 FindInsertIndexPhySecBlock_each <<PHYSEC_MAX>> if _L4)(_L5, _L9);
    _L4= true;
    _L5= - 1;
    _= _L3;
    outFindIndex= _L1;
    _L9= inPhySecBlockIdFlag_A;
  tel

end;

/* $********** SCADE Suite KCG 32-bit 6.6 (build i19) ***********
** -
** Generation date: 2020-01-13T16:36:01
*************************************************************$ */
